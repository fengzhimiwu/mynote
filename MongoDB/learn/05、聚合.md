mongodb的产生背景是在大数据环境，所谓的大数据实际上也就是进行的信息收集汇总。

信息统计操作，而这样的统计操作就称为聚合（直白：分组统计就是一种聚合操作）。

### 取得集合的数据量

对于集合的数据量而言，在mongodb里面直接使用count()函数就可以完成了。

范例：统计student表中的数据量

```
db.students.count();
```

范例：模糊查询

```
db.students.find({"name": /张/i});
```

在进行信息查询的时候，不设置条件永远要比设置条件的查询快很多，也就是说在之前的代码编写里面不管是查询全部还是模糊查询，实际上最终都使用的模糊查询一种（没有设置关键字）。

### 消除重复数据

在学习sql的时候对于重复的数据可以使用 distinct ，那么这一操作在mongodb之中依然支持。

范例：查询所有name的信息

- 本次的操作没有直接的函数支持，只能够利用runCommand()函数。

```
db.runCommand({"distinct": "students", "key": "name"});
```

此时实现了对于name数据的重复值筛选。

### group操作

使用 group 操作可以是新数据的分组操作，在mongodb里面将集合依据指定的key的不同进行分组操作，并且每一个组都会产生一个处理的文档结果。

范例：查询所有年龄大于19岁的学生信息，并且按照年龄分组

```
db.runCommand({"group": {
	"ns": "students",
	"key": {"age": true},
	"initial": {"count": 0},
	"condition": {"age": {"$gte": 19}},
	"$reduce": function(doc, prev) {
		prev.count++;// 表示数量加一
	}
}});
```

以上的操作代码里面实现的就属于一种MapReduce，但是这样只是根据传统的数据库的设计思路，实现了一个所谓的分组操作，但是这个分组操作的最终结果是有限的。

### MapReduce

mapreduce是整个大数据的精髓所在（实际中别用），所谓的MapReduce就是分为两步处理数据：

- Map：将数据分别取出；
- Reduce：负责数据的最后处理

可是要想在mongodb里面实现MapReduce处理，那么复杂毒是相当高的。

范例：建立一批雇员数据

```
db.emps.insert({"name": "张三", "age": 30, "sex": "男", "job": "CLERK", "salary": 1000});
db.emps.insert({"name": "李四", "age": 28, "sex": "女", "job": "CLERK", "salary": 5000});
db.emps.insert({"name": "王五", "age": 26, "sex": "男", "job": "MANAGER", "salary": 6000});
db.emps.insert({"name": "赵六", "age": 32, "sex": "女", "job": "MANAGER", "salary": 7000});
db.emps.insert({"name": "孙七", "age": 31, "sex": "男", "job": "CLERK", "salary": 2000});
db.emps.insert({"name": "王八", "age": 35, "sex": "女", "job": "PRESIDENT", "salary": 9000});
```

使用MapReduce操作最终会将处理结果保存在一个单独的集合里面，而最终的处理效果如下。

范例：按照职位分组，取得每个职位的人名

- 编写分组的定义：

```
var jopMapFun = function() {
	emit(this.job, this.name); // 按照job分组，取出name
}
例如：第一组 {key: "CLERK", values: [姓名，姓名 ......]}
```

- 编写Reduce操作：

```
var jobReduceFun = function(key, values) {
	return {"job": key ,names: values};
}
```

- 针对于MapReduce处理完成的数据实际上也可以执行一个最后处理

```
var jobFinalizeFun = function (key, values) {
	if (key == "PRESIDENT") {
		return {"job": key, "names": values, "info": "公司的老大"};
	}
	return {"job": key ,names: values};
}
```

- 进行操作的整合：

```
db.runCommand({
	"mapreduce": "emps",
	"map": jobMapFun,
	"reduce": jobReduceFun,
	"out": "t_job_emp",
	"finalize": jobFinalizeFun
});
```

现在执行之后，所有的处理结果都保存在了 t_job_emp 集合里面。 

范例：统计出各性别的人数、平均工资、最低工资、雇员姓名