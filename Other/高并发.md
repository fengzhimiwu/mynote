# 高并发大流量web解决思路及方案

 + [高并发web架构相关概念](#高并发web架构相关概念)
 + [高并发大流量web整体解决思路](#高并发大流量web整体解决思路)
 + [web服务器负载均衡](#web服务器负载均衡)
 + [cdn加速](#cdn加速)
 + [建立独立的图片服务器](#建立独立的图片服务器)
 + [动态页面静态化](#动态页面静态化)
 + [php并发编程实战](#php并发编程实战)
 + [mysql数据层的优化](#mysql数据层的优化)
 + [mysql缓存层的优化](#mysql缓存层的优化)

## 高并发web架构相关概念
- QPS:每秒钟请求或查询的数量，在互联网领域，指每秒相应请求数（http请求）。
- 峰值每秒的QPS：（总PV数\*80%）/（6小时秒数*20%），80%的访问量集中在20%的时间
- 并发连接数：系统同时处理的请求数量
- 吞吐量：单位时间内处理的请求数量（通常由QPS与并发数决定）。
- 响应时间：从请求发出到收到响应花费的时间。例如系统处理一个HTTP请求需要100ms，这个100ms就是系统的响应时间。
- PV：综合浏览量（Page View）即页面浏览量和点击量，一个访客在24小时内访问的页面数量。
- UV：独立访客（UniQue Visitor）,即一定时间范围内相同访客多次访问网站，只计算为1个独立访客。
- 带宽：计算带宽大小关注两个指标，峰值流量和平均页面大小。
- 日网站带宽=PV/统计时间（一天换算到秒）*平均页面大小（单位KB）*8。
- 压力测试：测试承受的最大并发，测试最大承受的QPS，需要注意的测试并发测试机需要与被测试机器分开，不要对线上服务器进行并发测试，观察ab测试的所在机器，以及被测试机器的前端机的CPU，内存，网络等都不超过最高限度的75%。
  - 并发量
  - 响应速度
  - 容错能力
- 常用的性能测试工具：ab，wrk，http_load，Web Bench,Siege,Apache JMeter。

## 高并发大流量web整体解决思路
- 流量优化
 - web资源防盗链防止第三方系统盗用图片，css，js等占用服务器流量和服务器带宽
- 前端优化
 - 减少http请求：图片合并，js合并，css合并压缩，虽然文件可能大点但请求会减少
 - 添加异步请求：通过实际ajax调用接口获取数据
 - 启动浏览器的缓存和文件压缩（也可以启用nginx的压缩模块）
 - cdn加速：解决带宽不够用的问题，数据缓存到cdn的节点，访问的时候选择就近的节点，减少带宽加快访问速度
 - 建立独立的图片服务器：图片是很吃io的，可以将图片服务器与web服务器完全分离开，可以区分其它服务器单独搭建图片服务器不属于计算型的配置可以适当的调整，图片服务器还可以集群
- 服务端的优化
  - 页面的静态化：动态的页面静态html,减少服务器的负载压力,页面静态化穿透，静态化有有效时间
  - 动态语言并发处理:异步处理，多线程，队列的异步处理
- 数据库的优化：
 - 数据库的缓存：memcache，redis的缓存
 - mysql索引优化，mysql分库分表，mysql分区操作，mysql主从复制读写分离，mysql的负载均衡，mysql的主从热备
- web服务器的优化：
 - 负载均衡：可以使用ningx的反向代理使用负载均衡，可以使用网络分层中的第四层lvs实现负载均衡

### web服务器负载均衡
#### 负债均衡
- 四层负载均衡：所谓四层负载均衡就是基于IP+端口的负载均衡
- 七层负载均衡：所谓七层的负载均衡就是基于（URL）信息的负载均衡

#### 七层负载均衡实现：
基于URL等应用层信息的负债均衡
ningx的proxy是它一个很强大的功能，实现了7层负载均衡，功能强大，性能卓越，运行稳定，配置简单灵活，能够自动剔除工作不正常的后端服务器，上传文件可以使用异步模式上传，支持多种分配策略，可以分配权重，分配方式灵活。

#### nginx负载均衡策略
- IP Hash(内置)
- 加权轮询（内置）
- fair策略（扩展）
- 通用hash（扩展）
- 一致性hash（扩展）

##### IP Hash策略

nginx内置的另一个负载均衡的策略，流程和轮询很相似，只是其中的算法和具体的策略有些变化，IP hash算法是一种变相的轮询算法

##### 加权轮训策略
首先将请求都分给高权重的机器，直到该机器的权值降到了比其他机器低，才开始将请求分给下一个高权重的机器，当所有后端机器都down掉时，nginx会立即将所有机器的标志位清成初始状态，以避免造成所有的机器都处在timeout的状态

##### fair策略
根据后端服务器的响应时间判断负载情况，从中选出负载最轻的机器进行分流

通用hash、一致性hash策略，通用hash比较简单，可以以nginx内置的变量为key进行hash，一致性hash采用了内置的一致性hash环，支持memcache

#### 四层负载均衡实现
通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器

lvs相关术语：

- DS:director server 目标服务器，即负载均衡器
- RS:Real Server 真实服务器，即后端服务器
- VIP：直接面向用户的IP地址，通常为公网IP地址
- DIP：Director Server Ip主要用于内部主机通信的IP地址
- RIP:Real Server IP 后端真实服务器的IP地址
- CIP:Client IP

lvs负载均衡三种方式：

 - NAT：修改目标IP地址为后端的RealServer的IP地址
 - DR：修改目标mac地址为后端的RealServer的mac地址
 - TUNNEL：较少使用，常用于异地容灾


#### 四七层负载均衡优缺点
- 四层比七层可以承载更大的并发量，使用大型站点小
- 七层可以实现更为复杂的负载均衡控制，比如URL、基于session、动静分离等
- 七层能够占用大量的CPU时间，承载的并发量

## cdn加速
#### 什么是cdn？

节点：可以理解为真实服务器的镜像。

全称是Content Delivery Network，即内容分发网络尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。

在网络各处放置节点服务器所构成的现有的互联网基础之上的一层智能虚拟网络。

cdn系统能够实时地根据网络流量和各节点的连接，负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。

#### cdn的优势是什么？
- 1.本地的cache加速，提高企业站点（尤其含有大量图片和静态页面站点）的访问速度
- 2.跨运营商的网络加速，保证不同网络的用户得到良好的访问质量
- 3.远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器
- 4.自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽，分担网络流量，减轻愿站点web服务器负载等功能。
- 5.广泛分布的cdn节点加上节点之间的智能冗余机制，可以有效的预防黑客入侵

#### cdn的工作原理是什么？

传统的访问：用户在浏览器输入域名发起请求，解析域名获取服务器ip地址，根据ip地址找到对应的服务器，服务器响应并返回数据。

使用cdn访问：用户发起请求，智能dns的解析（根据ip判断地理位置，接入网类型，选择路由最短和负载最轻的服务器），取得缓存服务器ip，把内容返回给用户（如果缓存中有），向源站发起请求，将结果访问给用户，将结果存入缓存服务器。

#### cdn的适用场景？
站点或者应用中大量静态资源的加速分发，例如：css，js，图片和html

#### cdn的实现方式？
- BAT等实现的CDN服务
- 使用LVS的4层负载均衡
- 可用nginx，varnish，squid，apache trafficServer做七层负载均衡和cache
使用squid做反向代理或者nginx做反向代理

## 建立独立的图片服务器
独立的必要性？

- 1.分担web服务器的I/O负载，将耗费资源的图片服务分离出来，提高服务器的性能和稳定性
- 2.能够专门对图片服务器进行优化，为图片服务设置针对性的缓存方案，减少带宽成本，提高访问速度

为啥采用独立的域名？

原因：同一域名下浏览器的并发连接数是有限制的，突破浏览器连接的限制，由于cookie的原因，对缓存不利，大部分web cache都只缓存不带cookie的请求，导致每次的图片请求都不能够命中cache

独立后的问题？

- 如何进行图片上传和图片同步
- NPS共享方式
- 利用FTP同步

## 动态页面静态化
相关概念：什么是动态语言静态化，为什么要静态化，静态化的实现方式。

## 动态语言的并发处理
### 什么是进程
进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础

进程是一个“执行中的程序”

#### 进程的状态的三态模型
多道程序系统中，进程在处理器上交替运行，状态不断发生变化。

- 运行：当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目，对于单处理机系统，处于运行状态的进程只有一个。在没有其它进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。
- 就绪：当一个进程获得了除处理机以外的一切所有资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪状态可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I/O操作完成而进入就绪状态时，排入高优先级队列。
- 阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。

### 什么是线程
由于用户的并发请求，为每一个请求都创建一个进程显然是行不通的，从系统资源开销方面或是响应用户请求的效率方面来看。因此操作系统中线程的概念便被引进了。

线程有时候被称为轻量级进程，是程序执行流的最小单元。

线程是进程中的一个实体，是被系统独立调度和分配的基本单位，线程自己不拥有系统资源，只拥有一点儿运行中必不可少的资源但它可与同属一个进程的其它线程共享进程所拥有的全部资源。

一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。

线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派cpu的基本单位指运行中的程序的调度单位。

#### 线程三状态
- 就绪状态：线程具备运行的所有条件，逻辑上可以运行，在等待处理机。
- 运行状态：线程占有处理机正在运行。
- 阻塞状态：线程在等待一个事件（如某个信号量），逻辑上不可执行。

### 什么是协程
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协称调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切的开销，可以不要加锁的访问全局变量，所以上下文的切换非常快。

### 线程和进程的区别？
- 1.线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间。
- 2.进程是资源分配和拥有的单位，同一个进程内的线程共享进程的资源。
- 3.线程是处理器调度的基本单位，但进程不是
- 4.二者都可以并发的执行
- 5.每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

### 线程和协程的区别？
- 1.一个线程可以多个协程，一个进程也可以单独拥有多个协程
- 2.线程进程都是同步机制，而协程则是异步
- 3.协称能够保留上一次调用时的状态，每次过程重入的时，就相当于进入上一次调用的状态

### 什么是多进程？
同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这就是多进程
多开一个进程，多分配一份资源，进程间通讯不方便

### 什么是多线程？
线程就是把一个进程分为很多片，每一片都可以是一个独立的流程，与多进程的区别是只会使用一个进程的资源，线程间可以通讯

### 多个概念之间的区别？
- 单进程单线程：一个人在一个桌上吃菜
- 单进程多线程：多个人在一个桌子上吃菜
- 多进程单线程：多个人每个人在自己桌子上吃菜

### 同步阻塞模型
多进程：最早的服务器端程序都是通过多进程，多线程来解决并发IO的问题一个请求创建一个进程，然后子进程进入循环同步堵塞地与客户端连接进行交互，收发处理数据。

#### 步骤
- 创建一个socket
- 进入while循环，阻塞在进程accept操作上，等待客户端连接进入主进程在多进程模型下通过fork创建子进程。

多线程模式下可以创建子线程

子线程/线程创建成功后进入while循环，阻塞在recv调用上，等待客户端向服务器发送数据

收到数据以后服务器程序进行处理然后使用send向客户端发送响应

当客户端连接关闭时，子进程/线程退出并销毁所有资源。主进程/线程会回收掉此子进程/线程。

这中模型严重的依赖进程的数量解决并发问题。

启动大量的进程会带来额外的进程调度消耗

### 异步非阻塞模型
现在各种高并发异步IO的服务器程序都是基于epoll实现的

IO复用异步非阻塞程序使用经典的Reactor模型，Reactor顾名思义就是反应堆的意思，它本身不处理任何数据收发。只是可以监视一个socket句柄的事件变化。

#### Reactor模型：
    - add：添加一个socket到reactor
    - set：修改socket对应的事件，如可读可写
    - del：从reactor中移除
    - callback：事件发生后回掉指定的函数

nginx：多线程Reactor

swoole：多线程Reactor+多进程worker

## php并发编程实战
- 1.php的swoole扩展、并行、高性能网络通信引擎，使用纯c语言编写提供了php语言的异步多线程服务器，异步tcp/udp网络客户端，异步mysql，异步redis，数据库连接池，AsyncTask，消息队列，毫秒定时器，异步文件读写，异步dns查询。
- 2.除了异步IO的支持之外，swoole为php多进程的模式设计了多个并发数据结构和IPC通信机制，可以大大简化多线程并发编程的工作
- 3.swoole2.0支持了类似Go语言的协程，可以使用完全同步的代码实现异步程序
- 4.消息队列
- 5.应用解耦
 - 场景说明：用户下单后，订单系统需要通知库存系统。
 - 假如库存系统无法访问，则订单减库存将失败，从而导致订单失败
 - 订单系统跟库存系统解耦
 - 引用队列
 - 用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功
 - 订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作
- 6.流量削峰
应用场景：秒杀活动，流量瞬间激增，服务器压力大
用户发起请求后，服务器接收后，先写入消息队列。假如消息队列长度超多最大值，则直接报错或提示用户
控制请求量，缓解高流量
- 7.日志处理
应用场景：解决大量日志的传输
日志采集程序将程序写入消息队列，然后通过日志处理程序的订阅消费日志。
- 8.消息通讯
聊天室
- 9.常见消息队列产品
kafka，ActiveMQ，ZeroMQ，RabbitMQ，Redis等
php的异步
消息队列
- 10.接口的并发请求
curl_multi_init

## mysql缓存层的优化
1.什么是数据库缓存

mysql等一些常见的关系型数据库的数据都存储在磁盘当中，在高并发场景下，业务应用对mysql产生的增删，改，查的操作造成巨大的I/O开销和查询压力，这无疑对数据库和服务器都是一种巨大的压力，为了解决此类问题，缓存数据的概念应运而生。
- 极大的解决数据库服务器的压力
- 提高应用数据的响应速度

常见的缓存形式：内存缓存和文件缓存

2.为什么要使用数据库缓存

- 缓存数据是为了让客户端很少甚至不访问数据库服务器进行数据的查询，高并发下，能最大程序地降低对数据库服务器的访问压力。
- 用户请求-》数据查询-》连接数据库服务器并查询数据-》将数据缓存起来（html，内存，json，序列化数据）-》显示给客户端
- 缓存方式的选择
- 缓存场景的选择
- 缓存数据的实时性
- 缓存数据的稳定性

3.使用mysql查询缓存

- 启用mysql查询缓存
- 极大的降低cpu使用率
- query_cache_type查询缓存类型，有0，1，2三个取值。0则不适用查询缓存。1表示始终使用查询缓存，2表示按需使用查询缓存。

query_cahce_type=1
select SQL_NO_CACHE * from my_table where condition;
query_cache_type=2
select SQL_CACHE * from my_table where condition;
query_cache_size

默认情况下query_cache_size为0，表示为查询缓存预留的内存为0，则无法使用查询缓存
SET GLOBAL query_cache_size = 134217728;
查询缓存可以看作是SQL文本和查询结果的映射
第二次查询的SQL和第一次查询的SQL完全相同，则会使用缓
SHOW STATUS LIKE ‘Qcache_hits’查看命中次数
表的结构和数据发生改变时，查询缓存中的数据不再有效

情理缓存：

- FLUSH QUERY CACHE;//清理查询缓存内存碎片
- RESET QUERY CACHE;//从查询缓存中移出所有查询
- FLUSH TABLES；//关闭所有打开的表，同时该操作将会清空查询缓存中的内容

4.使用Memcache缓存

对于大型站点，如果没有中间缓存层，当流量打入数据库层时，即便有之前的几层为我们挡住一部分流量，但是在大并发的情况下，还是会有大量请求涌入数据库层，这样对于数据库服务器的压力冲击很大，响应速度也会下降，因此添加中间缓存层很有必要。

memcache是一套分布式的高速缓存系统，由liveJournal的BrandFitzpatrick开发，但目前被许多网站使用以提升网站的访问速度，尤其对于一些大型的、需要频繁访问数据库的网站访问速度提升效果十分显著。
memcache是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像，视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存，然后从内存中读取，从而大大提高读取速度。

工作流程：先检查客户端的请求数据是否在memcache中，如有，直接把请求数据返回，不再对数据库进行任何操作；如果请求的数据不在memcache中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到memcached中。

通用缓存机制：用查询的方法名+参数作为查询时的key，value对中的key值

5.使用Redis缓存

与memcache的区别：

- 性能相差不大
- redis在2.0版本后增加了自己的VM特性，突破物理内存的限制，memcache可以修改最大可用内存，采用LRU算法
- redis依赖客户端来实现分布式读写
- memcache本身没有数据冗余机制
- redis支持（快照，aof）依赖快照进行持久化aof增强了可靠性的同时，对性能有所影响
- redis用户数据量较小的高性能操作和运算上
- memcache用于在动态系统中减少数据库负载，提升性能；适合做缓存提高性能。
- 可用于存储其他数据：session，session_set_save_handler

## mysql数据层的优化

- 数据表数据类型优化：int,smallint.,bigint,enum,ip存储使用int类型ip2long转化存入
- 索引不是越多越好，在合适的字段上创建合适的索引
- 符合索引的前缀原则
- like查询%的问题
- 全表扫描优化
- or条件索引使用情况
- 字符串类型索引失效的问题
- 优化查询数据过程中的数据访问，使用limit，尽量不要使用*，变复杂为简单，切分查询，分解关联查询*
-  优化特定类型查询语句，优化count()，优化关联查询语句，优化子查询，优化group by和distinct，优化limit和union
- 存储引擎的优化：尽量使用innodb
- 数据库表结构的优化：分区操作（对用户透明）partion，分库分表(水平拆分，垂直拆分做副表)
- 数据库服务器架构的优化：主从复制，读写分离，双主热备，负载均衡(lvs实现负载均衡，MyCat数据库中间件实现负载均衡)







####如何设计一个高并发的系统

> ① 数据库的优化，包括合理的事务隔离级别、SQL 语句优化、索引的优化
> ② 使用缓存，尽量减少数据库 IO
> ③ 分布式数据库、分布式缓存
> ④ 服务器的负载均衡

简述高并发网站解决方案。
A、前端优化（CND加速、建立独立图片服务器）
B、服务端优化（页面静态化、并发处理[异步|多线程]、队列处理）
C、数据库优化（数据库缓存[Memcachaed|Redis]、读写分离、分库分表、分区）
D、Web服务器优化（负载均衡、反向代理）

####如何处理负载、高并发？

从低成本、高性能和高扩张性的角度来说有如下处理方案：

1、HTML静态化
其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的 网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。
2、图片服务器分离
把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等
3、数据库集群和库表散列及缓存
数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。
4、镜像：
尽量减少下载，可以把不同的请求分发到多个镜像端。
5、负载均衡：
Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。

负载均衡 （Load Balancing） 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，同时能够提高网络的灵活性和可用性。目前使用最为广泛的负载均衡软件是Nginx、LVS、HAProxy。我分别来说下三种的优缺点:

Nginx的优点是：
工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。
Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大，这点本人深有体会；
Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。
可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。
Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。
Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。
Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。
Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有 lighttpd了，不过 lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。
Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。

Nginx的缺点是：
Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点。
对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过ip_hash来解决。

LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。

LVS的优点是：
抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。
配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。
工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived。
无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会受到大流量的影响。
应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。

LVS的缺点是：
软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。
如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有 Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。

HAProxy的特点是：
HAProxy也是支持虚拟主机的。
HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。
HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。
HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡。
HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：
① roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；
② static-rr，表示根据权重，建议关注；
③ leastconn，表示最少连接者先处理，建议关注；
④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；
⑤ ri，表示根据请求的URI；
⑥ rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parameter name；
⑦ hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；
⑧ rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。

Nginx和LVS对比的总结：

Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx有用的这些功能使其可调整度要高于LVS，所以经常要去触碰触碰，触碰多了，人为出问题的几率也就会大。

Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。

Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。

Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。

Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。

Nginx对请求的异步处理可以帮助节点服务器减轻负载，假如使用 apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大 量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。

Nginx能支持http、https和email（email的功能比较少用），LVS所支持的应用在这点上会比Nginx更多。在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给 LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。

数据库优化





