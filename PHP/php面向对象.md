# php面相对象知识整理

####oop是什么?

> oop是面向对象编程,面向对象编程是一种计算机编程架构,OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。
>
> *   OOP具有三大特点
>     1、**封装性**：也称为信息隐藏，就是将一个类的使用和实现分开，只保留部分接口和方法与外部联系，或者说只公开了一些供开发人员使用的方法。于是开发人员只 需要关注这个类如何使用，而不用去关心其具体的实现过程，这样就能实现MVC分工合作，也能有效避免程序间相互依赖，实现代码模块间松藕合。
>     2、**继承性**：就是子类自动继承其父级类中的属性和方法，并可以添加新的属性和方法或者对部分属性和方法进行重写。继承增加了代码的可重用性。PHP只支持单继承，也就是说一个子类只能有一个父类。
>     3、**多态性**：子类继承了来自父级类中的属性和方法，并对其中部分方法进行重写。于是多个子类中虽然都具有同一个方法，但是这些子类实例化的对象调用这些相同的方法后却可以获得完全不同的结果，这种技术就是多态性。多态性增强了软件的灵活性。
> *   优点：
>     1、**易维护**
>     采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的。
>     2、**质量高**
>     在设计时，可重用现有的，在以前的项目的领域中已被测试过的类使系统满足业务需求并具有较高的质量。
>     3、**效率高**
>     在软件开发时，根据设计的需要对现实世界的事物进行抽象，产生类。使用这样的方法解决问题，接近于日常生活和自然的思考方式，势必提高软件开发的效率和质量。
>     4、**易扩展**
>     由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展，而且成本较低。

####常用的魔术方法有哪些？举例说明

> php规定以两个下划线（\_\_）开头的方法都保留为魔术方法，所以建议大家函数名最好不用\_\_开头，除非是为了重载已有的魔术方法。
> _\_construct() 实例化类时自动调用。
> __destruct() 类对象使用结束时自动调用。
> _\_set() 在给未定义的属性赋值的时候调用。
> _\_get() 调用未定义的属性时候调用。
> _\_isset() 使用isset()或empty()函数时候会调用。
> _\_unset() 使用unset()时候会调用。
> _\_sleep() 使用serialize序列化时候调用。
> _\_wakeup() 使用unserialize反序列化的时候调用。
> _\_call() 调用一个不存在的方法的时候调用。
> _\_callStatic()调用一个不存在的静态方法是调用。
> _\_toString() 把对象转换成字符串的时候会调用。比如 echo。
> _\_invoke() 当尝试把对象当方法调用时调用。
> _\_set_state() 当使用var_export()函数时候调用。接受一个数组参数。
> _\_clone() 当使用clone复制一个对象时候调用。

####\_\_autoload()方法的工作原理是什么？

> 使用这个魔术函数的基本条件是类文件的文件名要和类的名字保持一致。
> 当程序执行到实例化某个类的时候，如果在实例化前没有引入这个类文件，那么就自动执行__autoload()函数。
> 这个函数会根据实例化的类的名称来查找这个类文件的路径，当判断这个类文件路径下确实存在这个类文件后
> 就执行include或者require来载入该类，然后程序继续执行，如果这个路径下不存在该文件时就提示错误。
> 使用自动载入的魔术函数可以不必要写很多个include或者require函数。

####\$this和self、parent这三个关键词分别代表什么？在哪些场合下使用？

\$this 当前对象
self 当前类
parent 当前类的父类

\$this在当前类中使用,使用->调用属性和方法
self也在当前类中使用，不过需要使用::调用
parent在类中使用

### self 和 static 的区别

`self ::` 在哪个类里调用的就调用哪个类中的方法，不受重写的影响。
`static ::` 调用的方法如果被子类重写，那调用的就是子类中的方法。

####作用域操作符::如何使用？都在哪些场合下使用？

调用类常量
调用静态方法

####接口和抽象类的区别是什么？

> 抽象类是一种不能被实例化的类，只能作为其他类的父类来使用。抽象类是通过关键字abstract来声明的。
> 抽象类与普通类相似，都包含成员变量和成员方法，两者的区别在于，抽象类中至少要包含一个抽象方法，抽象方法没有方法体，该方法天生就是要被子类重写的。
> 抽象方法的格式为：abstract function abstractMethod();
> 接口是通过 interface 关键字来声明的，接口中的成员常量和方法都是 public 的，方法可以不写关键字public，接口中的方法也是没有方法体。接口中的方法也天生就是要被子类实现的。
> 抽象类和接口实现的功能十分相似，最大的不同是接口能实现多继承。在应用中选择抽象类还是接口要看具体实现。
> 子类继承抽象类使用 extends，子类实现接口使用implements。