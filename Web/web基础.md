####1、http状态码都有哪些

> 一二三四五原则:（即一：消息系列；二：成功系列； 三：重定向系列；四：请求错误系列；五：服务器端错误系列。）1** 信息，服务器收到请求，需要请求者继续执行操作
> 2** 成功，操作被成功接收并处理
> 200 OK 请求成功。一般用于GET与POST请求
> 3** 重定向，需要进一步的操作以完成请求
> 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择
> 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
> 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
> 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看
> 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
> 305 Use Proxy 使用代理。所请求的资源必须通过代理访问
> 4** 客户端错误，请求包含语法错误或无法完成请求
> 400 Bad Request 客户端请求的语法错误，服务器无法理解
> 401 Unauthorized 请求要求用户的身份认证
> 402 Payment Required 保留，将来使用
> 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求
> 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
> 405 Method Not Allowed 客户端请求中的方法被禁止
> 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求
> 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权
> 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时
> 5** 服务器错误，服务器在处理请求的过程中发生了错误
> 500 Internal Server Error 服务器内部错误，无法完成请求
> 501 Not Implemented 服务器不支持请求的功能，无法完成请求
> 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
> 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中
> 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求
> 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理

####2、Http 和Https的区别

>第一：http是超文本传输协议，信息是明文传输，https是具有安全性的ssl加密传输协议
第二：http和https使用的是完全不同的连接方式，端口也不一样，前者80 或者443
第三：http连接很简单，是无状态的。https协议是由ssl+http协议构建的可进行加密传输，身份认证的网络协议。

####3、什么方法来加快页面的加载速度

>1，用到服务器资源时在打开，不用时，立即关闭服务器资源。
2，数据库添加索引
3，页面可生成静态
4，图片等大文件单独放在一个服务器
5，能不查询数据库的尽量不去数据取数据，可以放在缓存中。

####4、对于大流量的网站,采用什么样的方法来解决访问量问题?

>①.有效使用缓存，增加缓存命中率.
>②.使用负载均衡.
>③.对静态文件使用CDN进行存储和加速.
>④.想法减少数据库的使用.
>⑤.查看出现统计的瓶颈在哪里.
>反向代理

####5、AJAX的优势是什么？

ajax是异步传输技术，可以通过javascript实现，也可以通过JQuery框架实现，实现局部刷新，减轻了服务器的压力，也提高了用户体验。

对json数据格式的理解？
JSON(javascript object Notation)是一种轻量级的数据交换格式，json数据格式固定，可以被多种语言用作数据的传递。

长连接、短连接的区别和使用
长连接：client 方与 server 方先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。此种方式常用于 P2P 通信。

短连接：Client 方与 server 每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。C/S 通信。

长连接与短连接的使用时机：

长连接：

短连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。每个 TCP 连 接的建立都需要三次握手，每个 TCP 连接的断开要四次握手。如果每次操作都要建立连接然后再操作的话处理速度会降低，所以每次操作下次操作时直接发送数据 就可以了，不用再建立 TCP 连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成 socket 错误，频繁的 socket 创建也是对资源的浪 费。

短连接：

web 网站的 http 服务一般都用短连接。因为长连接对于服务器来说要耗费一定 的资源。像 web 网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。试想如果都用长连接，而且同时用成千上万的用户，每个用户都占有一个 连接的话，可想而知服务器的压力有多大。所以并发量大，但是每个用户又不需频繁操作的情况下需要短连接。

socket 连接步骤
Socket（套接字）概念

套接字（socket）是通信的基石，是支持 TCP/IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的 IP 地址，本地进程的协议端口，远地主机的 IP 地址，远地进程的协议端口。

Socket 连接过程

建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ，另一个运行于服务器端，称为 ServerSocket

套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认。

服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。

客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端

套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。



10. TCP 协议，三次握手、四次挥手
TCP 协议 (Transmission Control Protocol) 是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接，四次挥手断开连接。

位码即 tcp 标志位，有 6 种标示:

SYN (synchronous 建立联机) 同步

ACK (acknowledgement 确认)

PSH (push 传送)

FIN (finish 结束)

RST (reset 重置)

URG (urgent 紧急)

如何优化前端性能
1) 页面内容的优化

a) 降低请求数

合并 css、js 文件，集成 CSS 图片

b) 减少交互通信量

压缩技术：压缩 css、js 文件，优化图像，减少 cookie 体积；

合理利用缓存：使用外部 js/css 文件，缓存 ajax；

减少不必要的通信量：剔除无用脚本和样式、推迟加载内容、使用 GET 请求

c) 合理利用 “并行” 尽量避免重定向

慎用 Iframe 样式表置于顶部 脚本放到样式后面加载

d) 节约系统消耗

避免 CSS 表达式、滤镜

2) 服务器的优化

a) b)

c)

d)



19. yahoo 的 34 条前端优化法则
减少 HTTP 请求、利用 CDN 技术、 设置头文件过期或者静态缓存、Gzip 压缩、把 CSS 放顶部、 把 JS 放底部、避免 CSS 表达式、将 JS 和 CSS 外链、减少 DNS 查找、减小 JS 和 CSS 的体积、 避免重定向、删除重复脚本、 配置 ETags、缓存 Ajax、尽早的释放缓冲、

用 GET 方式进行 AJAX 请求、延迟加载组件、 预加载组件、减少 DOM 元素数量、跨域分离组件、

减少 iframe 数量、不要出现 404 页面、减小 Cookie、 对组件使用无 Cookie 的域名、减少 DOM 的访问次数、开发灵活的事件处理句柄、使用 <link> 而非 @import、避免过滤器的使用、优化图片、优化 CSS Sprites、 不要在 HTML 中缩放图片、缩小 favicon. ico 的大小并缓存它、保证组件在 25K 以下、将组件打包进一个多部分的文档中

304状态码详解

https://blog.csdn.net/Dongguabai/article/details/84323511
个人理解本地浏览器如果有缓存会自动带一些校验参数传递给服务器，服务器根据参数校验这个接口有没有变动过，有变动正常请求数据，返回200。没变动返回304，客户端展示缓存数据
磁盘满了怎么查询

#### [html5新特性总结](https://www.cnblogs.com/binguo666/p/10928907.html)

html5总的来说比html4多了十个新特性，但其不支持ie8及ie8以下版本的浏览器
一、语义标签
二、增强型表单
三、视频和音频
四、Canvas绘图
五、SVG绘图
六、地理定位
七、拖放API
八、WebWorker
九、WebStorage
十、WebSocket

####web开发中一般有哪些安全问题并简述一下原理和处理方式。

xss跨站脚本攻击
csrf跨站请求伪造（cross-site request forgery）
csrf实际上是用户登录网站a，然后登录钓鱼网站b的时候，不知情的情况下访问了b提供的访问a的链接。
防御方法
1.http refer,refer里记录来源网址，但是有的浏览器（ie ff2）可以自定义修改
2.请求地址里加上token验证，token存在session中，每次请求都带上token，验证用户合法性。缺点是改动量大，token也有可能会被获取到，有些论坛允许用户添加自己的网站链接，有可能也会在连接上带上用户token。
3.http头里增加自定义属性，通过xmlhttprequest类添加

####如何处理tcp粘包问题

https://www.jianshu.com/p/bb1377163ca7
TCP 是流式协议没有消息边界，客户端向服务器端发送一次数据，可能会被服务器端分成多次收到。
客户端向服务器端发送多条数据。服务器端可能一次全部收到。 保证传输的可靠性，顺序。
TCP拥有拥塞控制，所以数据包可能会延后发送。
TCP粘包
介绍
TCP 粘包是指发送方发送的若干包数据 到 接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。
原因
发送方：发送方需要等缓冲区满才发送出去，造成粘包
接收方：接收方不及时接收缓冲区的包，造成多个包接收
swoole处理粘包
EOF结束协议：
EOF切割需要遍历整个数据包的内容，查找EOF，因此会消耗大量CPU资源。上手比较简单
固定包头+包体协议
长度检测协议，只需要计算一次长度，数据处理仅进行指针偏移，性能非常高

26. HTTP 请求头信息和响应头信息
请求头信息

POST /scp1.1.0/prs/new_rnaseqtask/run_go HTTP/1.1

Host: 172.30.4.102

User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:6.0) Gecko/20100101 Firefox/6.0

Accept: /

Accept-Language: zh-cn,zh;q=0.5

Accept-Encoding: gzip, deflate

Accept-Charset: GB2312,utf-8;q=0.7,*;q=0.7

Connection: keep-alive

Content-Type: application/x-www-form-urlencoded; charset=UTF-8

X-Requested-With: XMLHttpRequest

Referer: http://172.30.4.102/scp1.1.0/index.php/prs... Content-Length: 1819

Cookie:

ci_session=a%3A4%3A%7Bs%3A10%3A%22session_id%22%3Bs%3A32%3A%22e31556053ff9407a454f6a1e146d43eb%22%3Bs%3A10%3A%22ip_address%22%3Bs%3A12%3A%22172.16.23.42%22%3Bs%3A10%3A%22user_agent%22%3Bs%3A50%3A%22Mozilla%2F5.0+%28Windows+NT+6.1%3B+rv%3A6.0%29+Gecko%2F2010010%22%3Bs%3A13%3A%22last_activity%22%3Bi%3A1314955607%3B%7D664b51a01ef99bac95f3e2206e79cb00;PHPSESSID=v33mlm1437lmop1fquta675vv4;username=linjinming; tk=1314955601855 Pragma: no-cache

Cache-Control: no-cache

响应头信息

HTTP/1.1 200 OK

Date: Fri, 02 Sep 2011 09:27:07 GMT

Server: Apache/2.2.3 (Red Hat)

X-Powered-By: PHP/5.1.6

Expires: Thu, 19 Nov 1981 08:52:00 GMT

Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0

Pragma: no-cache

Vary: Accept-Encoding

Content-Encoding: gzip

Content-Length: 31

Connection: close

Content-Type: text/html; charset=UTF-8



### 6. http与https的主要区别

```
1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

```

- [HTTP协议：工作原理](http://blog.csdn.net/anndy_/article/details/77198883)
- [SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)







作为一个互联网开发人员对于一些服务器返回的HTTP状态的意思都必须是了如指掌的，只有将这些状态码一一弄清楚，工作中遇到的各种问题才能够处理的得心应手。好了，下面就让我们来了解一下比较常见的HTTP状态码吧！
2开头 （请求成功）表示成功处理了请求的状态代码。
200  （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 
201  （已创建） 请求成功并且服务器创建了新的资源。 
202  （已接受） 服务器已接受请求，但尚未处理。 
203  （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 
204  （无内容） 服务器成功处理了请求，但没有返回任何内容。 
205  （重置内容） 服务器成功处理了请求，但没有返回任何内容。
206  （部分内容） 服务器成功处理了部分 GET 请求。
3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
300  （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 
301  （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
302  （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
303  （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
304  （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 
305  （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 
307  （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。
400  （错误请求） 服务器不理解请求的语法。 
401  （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 
403  （禁止） 服务器拒绝请求。
404  （未找到） 服务器找不到请求的网页。
405  （方法禁用） 禁用请求中指定的方法。 
406  （不接受） 无法使用请求的内容特性响应请求的网页。 
407  （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
408  （请求超时） 服务器等候请求时发生超时。 
409  （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 
410  （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 
411  （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 
412  （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 
413  （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 
414  （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 
415  （不支持的媒体类型） 请求的格式不受请求页面的支持。 
416  （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 
417  （未满足期望值） 服务器未满足"期望"请求标头字段的要求。
5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。
500  （服务器内部错误） 服务器遇到错误，无法完成请求。 
501  （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 
502  （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 
503  （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 
504  （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 
505  （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。






1xx - 信息提示
这些状态代码表示临时的响应。客户端在收到常规响应之前，应准备接收一个或多个 1xx 响应。
· 100 - Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新） 
· 101 - Switching Protocols 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）
2xx - 成功
这类状态代码表明服务器成功地接受了客户端请求。
· 200 - OK 一切正常，对GET和POST请求的应答文档跟在后面。 
· 201 - Created 服务器已经创建了文档，Location头给出了它的URL。 
· 202 - Accepted 已经接受请求，但处理尚未完成。 
· 203 - Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝，非权威性信息（HTTP 1.1新）。
· 204 - No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 
· 205 - Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。 
· 206 - Partial Content 客户发送了一个带有Range头的GET请求（分块请求），服务器完成了它（HTTP 1.1新）。
3xx - 重定向
客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。
· 300 - Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。 
· 301 - Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。 
· 302 - Found 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。出现该状态代码时，浏览器能
够自动访问新的URL，因此它是一个很有用的状态代码。注意这个状态代码有时候可以和301替换使 用。例如，如果浏览器错误地请求 http://host/~user （缺少了后面的斜杠）
，有的服务器返回301，有的则返回302。严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。 
· 303 - See Other 类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。 
· 304 - Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的
文档还可以继续使用。
· 305 - Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）。 
· 307 - Temporary Redirect 和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时 才能重
定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只 能跟随
对GET请求的重定向。（HTTP 1.1新）
4xx - 客户端错误
发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。
· 400 - Bad Request 请求出现语法错误。 
· 401 - Unauthorized 访问被拒绝，客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在 填写合
适的Authorization头后再次发出请求。IIS 定义了许多不同的 401 错误，它们指明更为具体的错误原因。这些具体的错误代码在浏览器中显示，但不在 IIS 日志中显示：
· 401.1 - 登录失败。
· 401.2 - 服务器配置导致登录失败。
· 401.3 - 由于 ACL 对资源的限制而未获得授权。
· 401.4 - 筛选器授权失败。
· 401.5 - ISAPI/CGI 应用程序授权失败。
· 401.7 – 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。
· 403 - Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。禁止访问：IIS 定义了许多不同的 403 错误，它们指
明更为具体的错误原因：
· 403.1 - 执行访问被禁止。
· 403.2 - 读访问被禁止。
· 403.3 - 写访问被禁止。
· 403.4 - 要求 SSL。
· 403.5 - 要求 SSL 128。
· 403.6 - IP 地址被拒绝。
· 403.7 - 要求客户端证书。
· 403.8 - 站点访问被拒绝。
· 403.9 - 用户数过多。
· 403.10 - 配置无效。
· 403.11 - 密码更改。
· 403.12 - 拒绝访问映射表。
· 403.13 - 客户端证书被吊销。
· 403.14 - 拒绝目录列表。
· 403.15 - 超出客户端访问许可。
· 403.16 - 客户端证书不受信任或无效。
· 403.17 - 客户端证书已过期或尚未生效。
· 403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。
· 403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。
· 403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。
· 404 - Not Found 无法找到指定位置的资源。这也是一个常用的应答。 
· 404.0 -（无） – 没有找到文件或目录。
· 404.1 - 无法在所请求的端口上访问 Web 站点。
· 404.2 - Web 服务扩展锁定策略阻止本请求。
· 404.3 - MIME 映射策略阻止本请求。
· 405 - Method Not Allowed 请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用，用来访问本页面的 HTTP 谓词不被允许（方法不被允许）（HTTP 1.1
新） 
· 406 - Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容，客户端浏览器不接受所请求页面的 MIME 类型（HTTP 1.1新）。 
· 407 - Proxy Authentication Required 要求进行代理身份验证，类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新） 
· 408 - Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新）
· 409 - Conflict 通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新） 
· 410 - Gone 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的
原因文档不可用。（HTTP 1.1新） 
· 411 - Length Required 服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新） 
· 412 - Precondition Failed 请求头中指定的一些前提条件失败（HTTP 1.1新）。
· 413 – Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1
新）。 
· 414 - Request URI Too Long URI太长（HTTP 1.1新）。 
· 415 – 不支持的媒体类型。
· 416 – Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新） · 417 – 执行失败。
· 423 – 锁定的错误。
5xx - 服务器错误
服务器由于遇到错误而不能完成该请求。
· 500 - Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求。 
· 500.12 - 应用程序正忙于在 Web 服务器上重新启动。
· 500.13 - Web 服务器太忙。
· 500.15 - 不允许直接请求 Global.asa。
· 500.16 – UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。
· 500.18 – URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。
· 500.100 - 内部 ASP 错误。
· 501 - Not Implemented 服务器不支持实现请求所需要的功能，页眉值指定了未实现的配置。例如，客户发出了一个服务器不支持的PUT请求。
· 502 - Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 亦说Web 服务器用作网关或代理服务器时收到了无效响应
。
· 502.1 - CGI 应用程序超时。
· 502.2 - CGI 应用程序出错。
· 503 - Service Unavailable 服务不可用，服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个
Retry-After头。这个错误代码为 IIS 6.0 所专用。
· 504 - Gateway Timeout 网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新） 。
· 505 - HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新）


----比如下面是我做图片上传的时候，判断是否是图片，而返回的状态码！--------
try
      {
        System.Drawing.Image img = System.Drawing.Image.FromStream(postedFile.InputStream);
        postedFile.SaveAs(savepath + @"\" + sNewFileName + sExtension);
        context.Response.Write(tempPath + sNewFileName + sExtension);
        context.Response.StatusCode = 200;
      }
      catch (ArgumentException ex)
      {
        context.Response.Write(ex.Message);
        context.Response.StatusCode = 403;
      }





# HTTP状态码


当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。
HTTP状态码的英文为HTTP Status Code。
下面是常见的HTTP状态码：
• 200 - 请求成功
• 301 - 资源（网页等）被永久转移到其它URL
• 404 - 请求的资源（网页等）不存在
• 500 - 内部服务器错误



## HTTP状态码分类


HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：

| 分类 | 分类描述                                       |
| :--- | :--------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |


HTTP状态码列表:

| 状态码 | 状态码英文名称                  | 中文描述                                                     |
| :----- | :------------------------------ | :----------------------------------------------------------- |
| 100    | Continue                        | 继续。客户端应继续其请求                                     |
| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|        |                                 |                                                              |
| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |
| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
|        |                                 |                                                              |
| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |
| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
|        |                                 |                                                              |
| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402    | Payment Required                | 保留，将来使用                                               |
| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409    | Conflict                        | 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 |
| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
|        |                                 |                                                              |
| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502    | Bad Gateway                     | 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求   |
| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

###get和post的区别

1.get参数通过url传递bai，post放在request body中。

2.get请求在url中传递的参数du是有长度限制的，而post没有。

3.get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。

4.get请求只能进行url编码，而post支持多种编码方式

5.get请求会浏览器zhi主动cache，而post支持多种编码方式。

6.get请求参数会被完整保dao留在浏览历史记录里，而post中的参数不会被保留。

7.GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

8.GET产生一个TCP数据包内；POST产生两个TCP数据包。

拓展资料：

对于容GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。