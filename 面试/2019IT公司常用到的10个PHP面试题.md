1.nginx使用哪种网络协议?

答：nginx是应用层，我觉得从下往上的话，传输层用的是tcp/ip，应用层用的是http,fastcgi负责调度进程!









2.eho,print,print_r的区别?

答：echo是语言结构，无返回值;print功能和echo基本相同，不同的是print是函数，有返回值;print_r是递归打印，用于输出数组对象。

3.求数组中最大数的下标?

答：1.functionmaxkey($arr){

2.$maxval=max($arr);3.foreach($arras$key=>$val){4.if($maxval==$val){5.$maxkey=$key;6.}7.}8.return$maxkey;9.}

10.$arr=array(0,-1,-2,5,”b”=>15,3);11.echomaxkey($arr);

输出：b









4.PHP有哪些特性?

答：①.php独特混合了C,Java,Prel以及PHP自创的语法.

②.可以比CGI或者Prel更快速去执行动态网页，与其他变成语言相比，PHP是讲程序嵌入到HTML文档中去执行，执行效率比完全生成HTML编辑的CGI要高很多，所有的CGI都能实现.

③.支持几乎所有流行的数据库以及操作系统.

④.PHP可以使用C,C++进行程序的扩展.









5.简述两种屏蔽php程序的notice警告的方法?

答：初始化变量，文件开始设置错误级别或者修改php.ini设置error_reportingset_error_handler和@抑制错误：

①在程序中添加：error_reporting(E_ALL&~E_NOTICE);②.或者修改php.ini中的：error_reporting=E_ALL改为：error_reporting=E_ALL&~E_NOTICE③.error_reporting(0);或者修改php.inidisplay_errors=Off









6.对于大流量的网站,您采用什么样的方法来解决访问量问题?

答：①.有效使用缓存，增加缓存命中率.

②.使用负载均衡.

③.对静态文件使用CDN进行存储和加速.

④.想法减少数据库的使用.

⑤.查看出现统计的瓶颈在哪里.









7.谈谈asp,php,jsp的优缺点?

答：①asp是需要依赖IIS,是微软开发的语言

②.php和jsp可以依赖apache或者nginx等其他服务器









8.下面哪个选项没有将john添加到users数组中?(B)

(A)$users=‘john’;(B)array_add($users,’john’);(C)array_push($users,‘john’);(D)$users||=‘john’;









9.写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名?

答：例如://www.sina.com.cn/abc/de/fg.php?id=1需要取出php或.php?

```
$url``=``"//www.sina.com.cn/abc/de/fg.php?id=1"``;
arr=parseurl(url);
pathArr=``pathinfo``(arr[``'path'``]);
print_r(``$pathArr``[``'extension'``]);
```









10.写一个函数，能够遍历一个文件夹下的所有文件和子文件夹?

答：如下.

```
functionaGetAllFile(``$folder``)
{
$aFileArr``=``array``;
if``(``is_dir``(``$folder``))
{
handle=opendir(folder);
while``((file=readdir(handle))!==false)
{
//如果是.或者..则跳过
if``(file==``"."``||file==``".."``)
{
continue``;
}
if``(``is_file``(folder.``"/"``.file))
{
aFileArr=file;
}
elseif``(``is_dir``(folder.``"/"``.file))
{
aFileArr[file]=aGetAllFile(folder.``"/"``.file);
}
}
closedir``(``$handle``);
}
return``$aFileArr``;
}
$path``=``"/home/test/sql"``;
```

7.mvc是什么?相互间有什么关系?

答:mvc是一种开发模式,主要分为三部分:m(model),也就是模型,负责数据的操作;v(view),也就是视图,负责前后台的显示;c(controller),也就是控制器,负责业务逻辑

客户端请求项目的控制器,如果执行过程中需要用到数据,控制器就会到模型中获取数据,再将获取到的数据通过视图显示出来

8.oop是什么?

答:oop是面向对象编程,面向对象编程是一种计算机编程架构,OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。
OOP具有三大特点
1、封装性：也称为信息隐藏，就是将一个类的使用和实现分开，只保留部分接口和方法与外部联系，或者说只公开了一些供开发人员使用的方法。于是开发人员只 需要关注这个类如何使用，而不用去关心其具体的实现过程，这样就能实现MVC分工合作，也能有效避免程序间相互依赖，实现代码模块间松藕合。

2、继承性：就是子类自动继承其父级类中的属性和方法，并可以添加新的属性和方法或者对部分属性和方法进行重写。继承增加了代码的可重用性。PHP只支持单继承，也就是说一个子类只能有一个父类。

3、多态性：子类继承了来自父级类中的属性和方法，并对其中部分方法进行重写。于是多个子类中虽然都具有同一个方法，但是这些子类实例化的对象调用这些相同的方法后却可以获得完全不同的结果，这种技术就是多态性。多态性增强了软件的灵活性。

1、易维护

采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的。

2、质量高

在设计时，可重用现有的，在以前的项目的领域中已被测试过的类使系统满足业务需求并具有较高的质量。

3、效率高

在软件开发时，根据设计的需要对现实世界的事物进行抽象，产生类。使用这样的方法解决问题，接近于日常生活和自然的思考方式，势必提高软件开发的效率和质量。

4、易扩展

由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展，而且成本较低。

9.smarty是什么,有什么作用?

回答一:smarty是用php写出来的模板引擎,也是目前业界最著名的php模板引擎之一

它分离了逻辑代码和外在的显示,提供了一种易于管理和使用的方法,用来将混杂的php逻辑代码与html代码进行分离

回答二:smarty是php中最著名的引擎框架之一,我们公司使用的是TP框架,已经封装好了smarty模板,所以没有单独使用过

回答三: smarty是个模板引擎，最显著的地方就是有可以把模板缓存起来。一般模板来说，都是做一个静态页面，然后在里面把一些动态的部分用一切分隔符切开，然后在PHP里打开这个模板文件，把分隔符里面的值替换掉，然后输出来，你可以看下PHPLib里面的template部分。

而smarty设定了缓存参数以后，第一次运行时候会把模板打开，在php替换里面值的时候把读取的html和php部分重新生成一个临时的php文件，这样就省去了每次打开都重新读取html了。如果修改了模板，只要重新刷下就行了。

10.TP框架有哪些优点?

答:TP框架是我们中国人自己开发的框架,各种资料比较齐全,国内用的比较多,比较简单和方便,而且是免费开源的

11.TP的特性有哪些?

1.多表查询非常方便,在model中几句代码就可以完成对多表的关联操作
2.融合了smarty模板,使前后台分离
3.支持多种缓存技术,尤其对memcache技术支持非常好
4.命名规范,模型,视图,控制器严格遵循命名规则,通过命名一一对应
5.支持多种url模式
6.内置ajax返回方法,包括xml,json,html等
7.支持应用扩展,类库扩展,驱动扩展等

12.TP框架中的大字母函数?

U:对url的组装
A:内部实例化控制器
S:缓存处理
R:调用某个控制器的操作方法
D:实例化自定义模型类
M:实例化基础模型类
I:获取参数
L:设置或者获取当前语言
C:设置或获取,保存配置

13.请介绍一下laravel框架?

答: laravel框架的设计思想比较先进,非常适合应用各种开发模式,作为一个框架,它为你准备好了一切,composer是php的未来,没有composer,php肯定要走向没落

laravel框架最大的特点和优秀之处就是集合了php比较新的特点,以及各种各样的设计模式,Ioc模式,依赖注入等

14.laravel有那些特点?

回答一:

```
1.强大的rest router:用简单的回调函数就可以调用,快速绑定controller和router
2.artisan:命令行工具,很多手动的工作都自动化
3.可继承的模板,简化view的开发和管理
4.blade模板:渲染速度更快
5.ORM操作数据库
6.migration:管理数据库和版本控制
7.测试功能也很强大
8.composer也是亮点
```

回答二:

laravel框架引入了门面,依赖注入,Ioc模式,以及各种各样的设计模式等

15.请简述一下数据库的优化?

答:数据库的优化可以从四个方面来优化:

1.从结构层: web服务器采用负载均衡服务器,mysql服务器采用主从复制,读写分离
2.从储存层: 采用合适的存储引擎,采用三范式
3.从设计层: 采用分区分表,索引,表的字段采用合适的字段属性,适当的采用逆范式,开启mysql缓存
4.sql语句层:结果一样的情况下,采用效率高,速度快节省资源的sql语句执行

16.如何解决异常处理?

答: 抛出异常:使用try…catch，异常的代码放在try代码块内，如果没有触发异常，则代码继续执行，如果异常被触发，就会 抛出一个异常。Catch代码块捕获异常，并创建一个包含异常信息的对象。$e->getMessage()，输出异常的错误信息。

解决异常:使用set_error_handler函数获取异常(也可以使用try()和catch()函数),然后使用set_exception_handler()函数设置默认的异常处理程序,register_shutdown_function()函数来执行,执行机制是,php要把调入的函数调入到内存,当页面所有的php语句都执行完成时,再调用此函数

17.前端?

答:我在工作中处理前端的功能，一般就是用ajax向后台请求数据，然后返回数据在前台页面中显示出来。我从来没有独立的完整的将html和css样式都一个人完成，如果公司实在有这样的需求的话，我可能会找一些前台的模板或者说是前端的框架，比如说h—ui等等

18.权限管理(RBAC)的实现?

1.首先创建一张用户表:id name auto(保存格式为:控制器-方法)

2.然后在后台中创建一个基类控制器,控制器里封装一个构造方法,当用户登陆成功后,使用TP框架中封装好的session函数获取保存在服务器中的session id,然后实例化模型,通过用户id获取保存在数据表中的auth数据,使用explode函数分割获取到的数据,并使用一个数组保存起来,然后使用TP框架中封装好的常量获取当前控制器和方法,然后把他们组装成字符串,使用in_array函数进行判断该数组中是否含有当前获取到的控制器和方法,如果没有,就提示该用户没有权限,如果有就进行下一步操作

19.支付功能的实现?

答:

20.怎么保证促销商品不会超卖?

答:这个问题是我们当时开发时遇到的一个难点，超卖的原因主要是下的订单的数目和我们要促销的商品的数目不一致导致的，每次总是订单的数比我们的促销商品的数目要多，当时我们的小组讨论了好久，给出了好几个方案来实现：

第一种方案：在每次下订单前我们判断促销商品的数量够不够，不够不允许下订单，更改库存量时加上一个条件，只更改商品库存大于0的商品的库存，当时我们使用ab进行压力测试，当并发超过500，访问量超过2000时，还是会出现超卖现象。所以被我们否定了。

第二种方案：使用mysql的事务加排他锁来解决，首先我们选择数据库的存储引擎为innoDB，使用的是排他锁实现的，刚开始的时候我们测试了下共享锁，发现还是会出现超卖的现象。有个问题是，当我们进行高并发测试时，对数据库的性能影响很大，导致数据库的压力很大，最终也被我们否定了。

第三种方案：使用文件锁实现。当用户抢到一件促销商品后先触发文件锁，防止其他用户进入，该用户抢到促销品后再解开文件锁，放其他用户进行操作。这样可以解决超卖的问题，但是会导致文件得I/O开销很大。

最后我们使用了redis的队列来实现。将要促销的商品数量以队列的方式存入redis中，每当用户抢到一件促销商品则从队列中删除一个数据，确保商品不会超卖。这个操作起来很方便，而且效率极高，最终我们采取这种方式来实现

21.商城秒杀的实现?

答:抢购、秒杀是如今很常见的一个应用场景，主要需要解决的问题有两个：

1 高并发对数据库产生的压力
2 竞争状态下如何解决库存的正确减少（"超卖"问题）
对于第一个问题，已经很容易想到用缓存来处理抢购，避免直接操作数据库，例如使用Redis。第二个问题，我们可以使用redis队列来完成，把要秒杀的商品放入到队列中，因为pop操作是原子的，即使有很多用户同时到达，也是依次执行，文件锁和事务在高并发下性能下降很快，当然还要考虑其他方面的东西，比如抢购页面做成静态的，通过ajax调用接口，其中也可能会出现一个用户抢多次的情况，这时候需要再加上一个排队队列和抢购结果队列及库存队列。高并发情况下，将用户进入排队队列，用一个线程循环处理从排队队列取出一个用户，判断用户是否已在抢购结果队列，如果在，则已抢购，否则未抢购，库存减1，写数据库，将用户入结果队列。

22.购物车的原理?

答:购物车相当于现实中超市的购物车，不同的是一个是实体车，一个是虚拟车而已。用户可以在购物网站的不同页面之间跳转，以选购自己喜爱的商品，点击购买时，该商品就自动保存到你的购物车中，重复选购后，最后将选中的所有商品放在购物车中统一到付款台结账，这也是尽量让客户体验到现实生活中购物的感觉。服务器通过追踪每个用户的行动，以保证在结账时每件商品都物有其主。

主要涉及以下几点:

1、把商品添加到购物车，即订购
2、删除购物车中已定购的商品
3、修改购物车中某一本图书的订购数量
4、清空购物车
5、显示购物车中商品清单及数量、价格

实现购物车的关键在于服务器识别每一个用户并维持与他们的联系。但是HTTP协议是一种“无状态(Stateless)”的协议，因而服务器不能记住是谁在购买商品，当把商品加入购物车时，服务器也不知道购物车里原先有些什么，使得用户在不同页面间跳转时购物车无法“随身携带”，这都给购物车的实现造成了一定的困难。

目前购物车的实现主要是通过cookie、session或结合数据库的方式。下面分析一下它们的机制及作用。

cookie

cookie是由服务器产生，存储在客户端的一段信息。它定义了一种Web服务器在客户端存储和返回信息的机制，cookie文件它包含域、路径、生存期、和由服务器设置的变量值等内容。当用户以后访问同一个Web服务器时，浏览器会把cookie原样发送给服务器。通过让服务器读取原先保存到客户端的信息，网站能够为浏览者提供一系列的方便，例如在线交易过程中标识用户身份、安全要求不高的场合避免用户重复输入名字和密码、门户网站的主页定制、有针对性地投放广告等等。利用cookie的特性，大大扩展了WEB应用程序的功能，不仅可以建立服务器与客户机的联系，因为cookie可以由服务器定制，因此还可以将购物信息生成cookie值存放在客户端，从而实现购物车的功能。用基于cookie的方式实现服务器与浏览器之间的会话或购物车，有以下特点：

1、cookie存储在客户端，且占用很少的资源，浏览器允许存放300个cookie，每个cookie的大小为4KB，足以满足购物车的要求，同时也减轻了服务器的负荷；
2、cookie为浏览器所内置，使用方便。即使用户不小心关闭了浏览器窗口，只要在cookie定义的有效期内，购物车中的信息也不会丢失；
3、cookie不是可执行文件，所以不会以任何方式执行，因此也不会带来病毒或攻击用户的系统；
4、基于cookie的购物车要求用户浏览器必须支持并设置为启用cookie，否则购物车则失效；
5、存在着关于cookie侵犯访问者隐私权的争论，因此有些用户会禁止本机的cookie功能。

session

session是实现购物车的另一种方法。session提供了可以保存和跟踪用户的状态信息的功能，使当前用户在session中定义的变量和对象能在页面之间共享，但是不能为应用中其他用户所访问，它与cookie最重大的区别是，session将用户在会话期间的私有信息存储在服务器端，提高了安全性。在服务器生成session后，客户端会生成一个sessionid识别号保存在客户端，以保持和服务器的同步。这个sessionid是只读的，如果客户端禁止cookie功能，session会通过在URL中附加参数，或隐含在表单中提交等其他方式在页面间传送。因此利用session实施对用户的管理则更为安全、有效。

同样，利用session也能实现购物车，这种方式的特点是：

1、session用新的机制保持与客户端的同步，不依赖于客户端设置；
2、与cookie相比，session是存储在服务器端的信息，因此显得更为安全，因此可将身份标示，购物等信息存储在session中；
3、session会占用服务器资源，加大服务器端的负载，尤其当并发用户很多时，会生成大量的session，影响服务器的性能；
4、因为session存储的信息更敏感，而且是以文件形式保存在服务器中，因此仍然存在着安全隐患。
结合数据库的方式

这也是目前较普遍的模式，在这种方式中，数据库承担着存储购物信息的作用，session或cookie则用来跟踪用户。这种方式具有以下特点：

1、数据库与cookie分别负责记录数据和维持会话，能发挥各自的优势，使安全性和服务器性能都得到了提高；
2、每一个购物的行为，都要直接建立与数据库的连接，直至对表的操作完成后，连接才释放。当并发用户很多时，会影响数据库的性能，因此，这对数据库的性能提出了更高的要求；
3、使cookie维持会话有赖客户端的支持。

各种方式的选择：

虽然cookie可用来实现购物车，但必须获得浏览器的支持，再加上它是存储在客户端的信息，极易被获取，所以这也限制了它存储更多，更重要的信息。所以一般cookie只用来维持与服务器的会话，例如国内最大的当当网络书店就是用cookie保持与客户的联系，但是这种方式最大的缺点是如果客户端不支持cookie就会使购物车失效。

Session能很好地与交易双方保持会话，可以忽视客户端的设置。在购物车技术中得到了广泛的应用。但session的文件属性使其仍然留有安全隐患。

结合数据库的方式虽然在一定程度上解决了上述的问题，但从上面的例子可以看出：在这种购物流程中涉及到对数据库表的频繁操作，尤其是用户每选购一次商品，都要与数据库进行连接，当用户很多的时候就加大了服务器与数据库的负荷。

23.redis消息队列先进先出需要注意什么?

答:通常使用一个list来实现队列操作，这样有一个小限制，所以的任务统一都是先进先出，如果想优先处理某个任务就不太好处理了，这就需要让队列有优先级的概念，我们就可以优先处理高级别的任务，实现方式有以下几种方式：

1）单一列表实现：队列正常的操作是 左进右出（lpush,rpop）为了先处理高优先级任务，在遇到高级别任务时，可以直接插队，直接放入队列头部（rpush），这样，从队列头部（右侧）获取任务时，取到的就是高优先级的任务（rpop）

2）使用两个队列，一个普通队列，一个高级队列，针对任务的级别放入不同的队列，获取任务时也很简单，redis的BRPOP命令可以按顺序从多个队列中取值，BRPOP会按照给出的 key 顺序查看，并在找到的第一个非空 list 的尾部弹出一个元素，redis> BRPOP list1 list2 0

list1 做为高优先级任务队列
list2 做为普通任务队列

这样就实现了先处理高优先级任务，当没有高优先级任务时，就去获取普通任务

方式1最简单，但实际应用比较局限，方式3可以实现复杂优先级，但实现比较复杂，不利于维护

方式2是推荐用法，实际应用最为合适
24.你负责的模块有哪些难题?

答:在我负责的B2B电商项目中，当时我负责的是订单模块，由于客户一次选择了多家商户的商品，最终生成了一个订单，这样我们平台在给商户结算时出现了不知道这比费用应该给哪个商户，这时候我们小组经过讨论，需要涉及到订单拆分，也就是说用户点击支付后,如果有多件商品,并且不是同一家店铺那么 就要用到订单的拆分,比如如果有两件商品,并且不是同一店铺 就在原来的订单号下 在生成两个子订单号 并修改订单表中两件商品的订单号。最终实现了商品的分配管理，解决了我们的难题。

我觉得在开发过程中，遇到的难题无非是两个，一个是技术层次的，我认为，只要你有恒心，有热心，没有觉得不了的难题。另一个就是沟通问题，在任何地方任何时候沟通都是最重要的，尤其是我们做开发的，不沟通好，会影响整个项目的进度，我本人是个非常还沟通的人，所以这点上也没多大问题。

25.用户下单是怎么处理的?

答:判断用户有没有登录，在没有登录的情况下，不允许下单。登陆后，可进行下单,并生成唯一的订单号，此时订单的状态为未支付。

26.电商的登录是怎么实现的?

答:分为普通登录和第三方登录 这边主要说一下第三方登录吧，第三方登陆主要使用的是author协议，我就以QQ的第三方登陆为例来进行说明：当用户在我们的站点请求QQ的第三方登陆时，我们站点会引导用户跳转到QQ的登陆授权界面， 当用户输入QQ和密码成功登录以后会自动跳回到我们站点设置好的回调页面，并附带一个code参数，接着你使用code再次去请求QQ的授权页面，就可以从中获取到一个access token（访问令牌），通过这个access_token，我们可以调用QQ提供给我们的接口，比如获取open_id，可以获取用户的基本信息。获取到之后，我们需要拿用户的授权信息和open_id和我们平台的普通用户进行绑定。这样不管是普通用户登陆还是第三方登陆用户，都可以实现登陆。

27.接口安全方面是怎么处理的?

答:我们当时是这么做的，使用HTTP的POST方式,对固定参数+附加参数进行数字签名,使用的是md5加密,比如:我想通过标题获取一个信息,在客户端使用 信息标题+日期+双方约定好的一个key通过md5加密生成一个签名(sign),然后作为参数传递到服务器端,服务器端使用同样的方法进行校验,如何接受过来的sign和我们通过算法算的值相同，证明是一个正常的接口请求，我们才会返回相应的接口数据。

28.用的什么技术实现短信发送，在哪调用?

答:我主要用的第三方短信接口，在申请接口时进行相应信息的配置，然后在我们站点需要用到短信验证的地方进行调用，我们通常在用户注册时使用到。

29.在工作中遇到什么困难?

答:总体来说：在工作我主要遇到这几个问题比较难处理：

①我之前工作的时候发现经常会出现一些临时需求打乱了我的计划，搞得有时候这个任务还没完成，又得去做其他的任务，最后一天下来，大大小小的东西是很多，但是没有完成得非常好的，后面我总结了一下，我会把这些都添加优先级，遇到临时需求，按照优先级重新将已有任务和临时任务进行排版，保证在规定时间内有效率的完成优先级高的任务。

②在做项目需求时候，遇到理解能力欠佳的人，沟通时容易被气到，影响自己的情绪，最后反倒还不能到达需要的效果。后面，每次到这种时候，我一般会借助一些纸质的、更加形象的东西，让双方都认同的、都能明白的一种方式来进行沟通，后面减少了很多不必须的麻烦。大家都知道，对于程序员来说，改需求是一件很痛苦的事情，所以前期的沟通工作很重要。

③还有一件事时，我以前的领导不太懂技术，所以每次出一个新的需求出来，总是要求我们在很短的时间内完成，完不成我们就会被怀疑能力有问题。当然，每个领导都希望自己的员工能够尽快的完成任务，降低成本，提高效率。这时候我会把我们的需求细化，把其中的重点、难点都列出来，做好时间规划，耐心的跟领导沟通，项目每个点的重要性和时间的花费比例，确保在这个规划的时间点内保质保量的完成任务。慢慢的也得到了领导的认可，其实领导也不是一味的不通情理，只要把东西计划好了，以最小的代价换取最高的价值，每个人都是很容易理解得

30.用户不登录，怎么直接加入购物车的?

答:用户在不登录的情况下，可以把要购买商品的信息（如商品的ID，商品的价格、商品的sku_id,购买数量等关键数据）存到COOKIE里面，当登陆的情况下。把COOKIE里面的内容存到数据库，并清除cookie中的数据。

31.写过接口吗，怎么定义接口的?

答：写过。接口分为两种：一种是数据型接口，一种是应用型接口。

数据型接口：是比抽象类更抽象的某种“结构”——它其实不是类，但是跟类一样的某种语法结构，是一种结构规范，规范我们类要以什么格式进行定义，一般用于团队比较大，分支比较多的情况下使用。

应用型接口： API（application interface） 数据对外访问的一个入口

我主要是参与的APP开发中接口的编写，客户端需要什么样的数据，我们就给他们提供相应的数据，数据以json/xml的格式返回，并且配以相应的接口文档。

32.sku减库存?

答:SKU = Stock Keeping Unit (库存量单位)

即库存进出计量的单位，可以是以件，盒，托盘等为单位。SKU是库存量单位，区分单品。

在服装、鞋类商品中使用最多最普遍。 例如纺织品中一个SKU通常表示：规格、颜色、款式。

在设计表时，不仅仅只有商品表，商品表中有个总库存，我们还需要涉及一张SKU表，里面有SKU库存和单价字段，用户每购买一件商品，实际上购买的都是SKU商品，这样在下订单成功后，应该根据所购买的商品的唯一的SKU号来进行相应的SKU库存的减少，当然商品的总库存保存在商品主表中，也需要减少总库存中的库存量。

33.库存设置？

答:库存分为商品总库存和SKU库存，往往商品总库存的为SKU库存的总和。一般在商城的后台对货品设置最高库存及最低库存后，当前库存数量与最高、最低两者比较，超出库存或者低于库存的，则被统计成报表形式反映，便于用户掌握货品库存超、短缺状态及数量。

34.订单、库存两个表 如何保证数据的一致性？

答：在一个电子商务系统中，正常的应该是订单生成成功后，相应的库存进行减少必须要保证两者的一致性，但有时候因为某些原因，比如程序逻辑问题，并发等问题，导致下单成功而库存没有减少的情况。这种情况我们是不允许发生的，MySQL的中的事务刚好可以解决这一问题，首先得选择数据库的存储引擎为InnoDB的，事务规定了只有下订单完成了，并且相应的库存减少了才允许提交事务，否则就事务回滚，确保数据一致性。

35.O2O用户下单，c端下单，如何保证ba端数据一致？

答：O2O为线上和线下模式，O2O模式奉行的是“线上支付+实体店消费”的消费模式，即消费者在网上下单完成支付后，凭消费凭证到实体店消费。 O2O模式是把商家信息和支付程序放在线上进行，而把商品和服务兑现放在线下，也就是说O2O模式适用于快递无法送达的有形产品。数据一致性的问题是O2O行业中最常见的问题，我们可以类似于数据库的主从复制的思路来解决这个问题.O2O有个供应商系统，类似于主服务器，在ç端（从服务器）下单时，数据同步更新到供应商系统端，b，a实时从供应商系统中拉取数据进行同步，比如利用定时任务，定时拉取数据进行同步。

36.Redis如何防止高并发?

答：其实redis是不会存在并发问题的，因为他是单进程的，再多的命令都是一个接一个地执行的。我们使用的时候，可能会出现并发问题，比如获得和设定这一对。Redis的为什么 有高并发问题？Redis的的出身决定

Redis是一种单线程机制的nosql数据库，基于key-value，数据可持久化落盘。由于单线程所以redis本身并没有锁的概念，多个客户端连接并不存在竞争关系，但是利用jedis等客户端对redis进行并发访问时会出现问题。发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。

同时，单线程的天性决定，高并发对同一个键的操作会排队处理，如果并发量很大，可能造成后来的请求超时。

在远程访问redis的时候，因为网络等原因造成高并发访问延迟返回的问题。

解决办法

在客户端将连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。

服务器角度，利用setnx变向实现锁机制。

37.秒杀当中的细节你是怎么得出来的?

答:通过性能测试及模拟秒杀场景。每个问题都经过反复测试，不断的发现问题，不断的解决。

38.做秒杀用什么数据库，怎么实现的?

答:因为秒杀的一瞬间，并发非常大，如果同时请求数据库，会导致数据库的压力非常大，导致数据库的性能急剧下降，更严重的可能会导致数据库服务器宕机。这时候一般采用内存高速缓存数据库redis来实现的,redis是非关系型数据库，redis是单线程的，通过redis的队列可以完成秒杀过程。

39.支付宝流程怎么实现的?

答:首先要有一个支付宝账号，接下来向支付宝申请在线支付业务，签署协议。协议生效后有支付宝一方会给网站方一个合作伙伴ID,和安全校验码，有了这两样东西就可以按照支付宝接口文档开发支付宝接口了，中间主要涉及到一个安全问题。整个流程是这样的：我们的网站通过post传递相应的参数（如订单总金额，订单号）到支付页面，支付页面把一系列的参数经过处理，以post的方式提交给支付宝服务器，支付宝服务器进行验证，并对接收的数据进行处理，把处理后的结果返回给我们网站设置的异步和同步回调地址，通过相应的返回参数，来处理相应的业务逻辑，比如返回的参数代表支付成功，更改订单状态。

40.什么是单点登录？

答:单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。

41.什么情况下使用缓存?

答:当用户第一次访问应用系统的时候，因为还没有登录，会被引导到认证系统中进行登录；根据用户提供的登录信息，认证系统进行身份校验，如果通过校验，应该返回给用户一个认证的凭据－－ticket；用户再访问别的应用的时候，就会将这个ticket带上，作为自己认证的凭据，应用系统接受到请求之后会把 ticket送到认证系统进行校验，检查ticket的合法性。如果通过校验，用户就可以在不用再次登录的情况下访问应用系统2和应用系统3了。

实现主要技术点：

1、两个站点共用一个数据验证系统
2、主要通过跨域请求的方式来实现验证及session处理。

42.怎么实现第三方登录？

答:第三方登陆主要是基于author协议来实现，下面简单说下实现流程:

1、首先我们需要以开发者的身份向第三方登陆平台申请接入应用，申请成功后，我们会获得一个appID和一个secrectID.
2、当我们的网站需接入第三方登陆时，会引导用户跳转到第三方的登陆授权页面，此时把之前申请的appID和secrectID带给登陆授权页面。
3、用户登陆成功后即得到授权，第三方会返回一个临时的code给我们的网站。
4、我们的网站接受到code后，再次向我们的第三方发起请求，并携带接收的code,从第三方获取access_token.
5、第三方处理请求后，会返回一个access_token给我们的网站，我们的网站获取到access_token后就可以调用第三方提供的接口了，比如获取用户信息等。最后把该用户信息存入到我们站点的数据库，并把信息保存到session中，实现用户的第三方登陆。

43.如何处理负载、高并发？(好好看看，经常问到，能回答到主要的东西即可)?

答:从低成本、高性能和高扩张性的角度来说有如下处理方案：

1、HTML静态化

其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的 网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。

2、图片服务器分离

把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等

3、数据库集群和库表散列及缓存

数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。

4、镜像：

尽量减少下载，可以把不同的请求分发到多个镜像端。

5、负载均衡：

Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。

负载均衡 （Load Balancing） 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，同时能够提高网络的灵活性和可用性。目前使用最为广泛的负载均衡软件是Nginx、LVS、HAProxy。我分别来说下三种的优缺点:

Nginx的优点是：

工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。

Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大，这点本人深有体会；

Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。

可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。

Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。

Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。

Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。

Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有 lighttpd了，不过 lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。

Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。

Nginx的缺点是：

Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点。

对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过ip_hash来解决。

LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。

LVS的优点是：

抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。

配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。

工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived。

无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会受到大流量的影响。

应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。

LVS的缺点是：

软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。

如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有 Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。

HAProxy的特点是：

HAProxy也是支持虚拟主机的。

HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。

HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。

HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡。

HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：

① roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；

② static-rr，表示根据权重，建议关注；

③ leastconn，表示最少连接者先处理，建议关注；

④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；

⑤ ri，表示根据请求的URI；

⑥ rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parameter name；

⑦ hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；

⑧ rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。

Nginx和LVS对比的总结：

Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx有用的这些功能使其可调整度要高于LVS，所以经常要去触碰触碰，触碰多了，人为出问题的几率也就会大。

Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。

Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。

Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。

Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。

Nginx对请求的异步处理可以帮助节点服务器减轻负载，假如使用 apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大 量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。

Nginx能支持http、https和email（email的功能比较少用），LVS所支持的应用在这点上会比Nginx更多。在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给 LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。

数据库优化

44.做秒杀时锁表考虑到没有？

答:考虑到了，当时我们做秒杀时考虑了好几种方案，其中有一种就是使用事务加上排他锁来实现。

加粗样式45.架构类的东西接触过吗？

有接触过，曾经自己在自己的服务器上配置过。我以前做过以下几个架构方面的配置和测试;

1、数据库的读写分离、主从复制及集群。
2、Nginx负载均衡
3、redis集群及主从

46.封装过一个简单的框架?

答;封装过一个简单的MVC框架,主要分为3层，控制器层和模型层视图层，以及路由的分配和入口文件，模板引擎，单例模式、工厂模式，第三方类库的引入等。

47.谈谈对MVC的认识?

答:核心思想是：视图和用户交互通过事件导致控制器改变 控制器改变导致模型改变 或者控制器同时改变两者 模型改变 导致视图改变 或者视图改变 潜在的从模型里面获得参数 来改变自己。他的好处是可以将界面和业务逻辑分离。

Model（模型），是程序的主体部分，主要包含业务数据和业务逻辑。在模型层，还会涉及到用户发布的服务，在服务中会根据不同的业务需求，更新业务模型中的数据。
View(视图），是程序呈现给用户的部分，是用户和程序交互的接口，用户会根据具体的业务需求，在View视图层输入自己特定的业务数据，并通过界面的事件交互，将对应的输入参数提交给后台控制器进行处理。
Contorller（控制器），Contorller是用来处理用户 输入数据，已经更新业务模型的部分。控制器中接收了用户与界面交互时传递过来的数据，并根据数据业务逻辑来执行服务的调用和更新业务模型的数据和状态。

48.session与cookie的区别

1、cookie数据存放在第三方应用的浏览器上，session数据放在服务器上。

2、cookie不是很安全，别人可以分析存放在本地的COOKIE，进行COOKIE欺骗,考虑到安全应当使用session。

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE。

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE

49.echo(),print(),print_r()的区别?

echo可以一次输出多个值，多个值之间用逗号分隔。echo是语言结构(language construct)，而并不是真正的函数，因此不能作为表达式的一部分使用。echo是php的内部指令，不是函数，无返回值。

print()：函数print()打印一个值（它的参数），如果字符串成功显示则返回true，否则返回false。只能打印出简单类型变量的值(如int,string)，有返回值

printf()：源于C语言中的printf()。该函数输出格式化的字符串。

print_r()和var_dump()
print_r()可以把字符串和数字简单地打印出来，而数组则以括起来的键和值得列表形式显示，并以Array开头。但print_r()输出布尔值和NULL的结果没有意义，因为都是打印"\n"。因此用var_dump()函数更适合调试。print_r是函数，可以打印出比较复杂的变量(如数组，对象)，有返回值
var_dump()判断一个变量的类型与长度,并输出变量的数值,如果变量有值输的是变量的值并回返数据类型。此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。

50.说一下单引号双引号？
①单引号内部的变量不会执行， 双引号会执行

②单引号解析速度比双引号快。

③单引号只能解析部分特殊字符，双引号可以解析所有特殊字符。

51.索引的优缺点?

1、优点：

a）可以保证数据库表中每一行的数据的唯一性
b）可以大大加快数据的索引速度
c）加速表与表之间的连接，物别是在实现数据的参考完事性方面特别有意义
d）在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
f）通过使用索引，可以在时间查询的过程中，使用优化隐藏器，提高系统的性能

2、 缺点：

a)  创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
b)  索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大
c)  以表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度
d)  建立索引的原则
e)  在经常需要搜索的列上，可以加快搜索的速度
f)  在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构
g)  在经常用在连接的列上，这些列主要是一外键，可以加快连接的速度
h)  在经经常需要根据范围进行搜索的列上创建索引，国为索引已经排序，其指定的范围是连续的
i)  在经常需要排序的列上，国为索引已经排序，这样井底可以利用索引的排序，加快排序井底时间
j)  在经常使用在where子句中的列上，加快条件的判断速度

52.get和post的区别?

1. get是从服务器上获取数据，post是向服务器传送数据。
2. get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。
3. get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。
4. get安全性非常低，post安全性较高。但是执行效率却比Post方法好。

53.如何修改会话的生存时间？

一：在php.ini中设置session.gc_maxlifetime = 1440 //默认时间
二：代码实现      $ lifeTime = 24 * 3600; //保存一天
    session_set_cookie_params（$ lifeTime）; 
    在session_start（）;

54.Linux基本命令，目录结构？

```
arch显示机器的处理器架构
（1） uname -m显示机器的处理器架构
（2） uname -r显示正在使用的内核版本 
dmidecode -q显示硬件系统部件 - （SMBIOS / DMI）   
hdparm -i / dev / hda罗列一个磁盘的架构特性    
hdparm -tT / dev / sda在磁盘上执行测试性读取操作 
cat / porc / cpuinfo显示CPU信息 
cat / porc / interrupts显示中断
cat / porc / meminfo校验内存使用  
cat / porc / swaps显示哪些交换被使用 
cat / porc / verion显示内核的版本
cat /porc/net/dev 显示网络适配器及统计 
cat /porc/mounts 显示已加载的文件系统 
 
date 显示系统日期 
cal 2007 显示2007年的日历表 
date 041217002007.00 设置日期和时间 -月日时分年.秒 
clock -w 将时间修改保存到 BIOS 
 
文件搜索 
find / -name file1 从 '/'开始进入根文件系统搜索文件和目录 
 
locate \*.ps 寻找以 '.ps'结尾的文件 -先运行'updatedb'命令 
whereis halt 显示一个二进制文件、源码或man的位置 
which halt 显示一个二进制文件或可执行文件的完整路径 
 
挂载一个文件系统 
mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘- 确定目录'/ mnt/hda2' 已经存在 
umount /dev/hda2 卸载一个叫做hda2的盘- 先从挂载点'/ mnt/hda2' 退出 
 
追加命令
 
1,linux里把文件/etc/aaa中的内容追加到/usr/bbb中的内容的后面
  sudo cat /etc/aaa >>/usr/bbb
2,更改/etc/index.html的文件所有者为apache,文件群组为apache
  sudo chmod apache:apache  /etc/index.html
3,更改/etc/index.html的所有者权限为读取、写入、执行。群组权限为读取。其他权限为读取
  sudo chmod 744 /etc/index.html
4，删除/etc下名为hello的文件
  sudo rm /etc/index.html
 
当然，如果你是以orot用户执行以上操作，可以去掉前边的sudo！
 
df -hl 查看磁盘剩余空间
 
df -h 查看每个根路径的分区大小
 
du -sh [目录名] 返回该目录的大小
 
du -sm [文件夹] 返回该文件夹总M数
 
关机 (系统的关机、重启以及登出) 
shutdown -h now 关闭系统(1) 
init 0 关闭系统(2) 
telinit 0 关闭系统(3) 
shutdown -h hour:minutes & 按预定时间关闭系统 
shutdown -c 取消按预定时间关闭系统 
shutdown -r now 重启(1) 
reboot 重启(2) 
logout 注销
 
文件和目录 
pwd 显示工作路径 
ls 查看目录中的文件 
ls -F 查看目录中的文件 
ls -l 显示文件和目录的详细资料 
ls -a 显示隐藏文件 
ls *[0-9]* 显示包含数字的文件名和目录名 
tree 显示文件和目录由根目录开始的树形结构(1) 
lstree 显示文件和目录由根目录开始的树形结构(2) 
mkdir dir1 创建一个叫做 'dir1'的目录' 
 
磁盘空间 
df -h 显示已经挂载的分区列表 
ls -lSr |more 以尺寸大小排列文件和目录 
du -sh dir1 估算目录 'dir1'已经使用的磁盘空间' 
 
下载、解压
 
1)对于.tar结尾的文件 
　　tar -xf all.tar 
 
2)对于.gz结尾的文件 
　　gzip -d all.gz 
　　gunzip all.gz 
 
# zip all.zip *.jpg 
　　这条命令是将所有.jpg的文件压缩成一个zip包 
# unzip all.zip 
　　这条命令是将all.zip中的所有文件解压出来
 
下载命令
 
wget + 空格 +要下载文件的url路径
 
=====================================
 
Shell 脚本：
 
必须以  #!/bin/sh  开头
 
简单例子：判断这个目录下有没有文件（File）
 
#!/bin/bash
Num=`ls -al /opt |grep "^-"|wc -l `
if [ $Num != 0 ]
 then echo "/opt has $Num files"
else
 echo "/opt has none file"
fi
 
ls -al /opt |grep "^-"|wc -l  这个命令能够统计文件个数 为0就是没有文件 非零就是有文件
```

55…memcache缓存什么数据?

一、经常被读取并且实时性要求不强可以等到自动过期的数据。例如网站首页最新文章列表、某某排行等数据。
二、经常被读取并且实时性要求强的数据。比如用户的好友列表，用户文章列表，用户阅读记录等。
三、统计类缓存，比如文章浏览数、网站PV等。
四、活跃用户的基本信息或者某篇热门文章。

五、session数据

魔术常量:

```
__LINE__
返回文件中的当前行号。
 
__FILE__
返回文件的完整路径和文件名。如果用在包含文件中，则返回包含文件名。自 PHP 4.0.2 起，__FILE__ 总是包含一个绝对路径，而在此之前的版本有时会包含一个相对路径。
 
__FUNCTION__
返回函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在PHP 4 中该值总是小写字母的。
 
__CLasS__
返回类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在PHP 4 中该值总是小写字母的。
 
__METHOD__
返回类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。
 
__set()当程序试图写入一个不存在或者不可见的成员变量时，__set()方法包含两个参数，分别表示变量名称和变量值，两个参数都不可省略
 
__get()当程序试图调用一个未定义或不可见的成员变量时，__get()方法有一个参数，表示要调用的变量名
 
__sleep() 常用于提交未提交的数据，或类似的清理操作如果有一些很大的对象，但不需要全部保存，这个功能就很好用。
 
__construct()  在类实例化对象的同时执行该函数
 
__distruct() 在类实例化的对象销毁时执行
 
__call()对象调用某个方法，若方法存在，则直接调用；若不存在，则会去调用__call函数。
 
__clone()克隆对象时被调用。如：$t=new Test();$t1=clone $t;
 
__toString()打印一个对象的时被调用。如echo $obj;或print $obj;
 
__isset()检测一个对象的属性是否存在时被调用。如：isset($c->name)。
 
__unset()unset一个对象的属性时被调用。如：unset($c->name)。
 
__autoload()实例化一个对象时，如果对应的类不存在，则该方法被调用。
```

57.接口和抽象类的区别是什么？

答:抽象类是一种不能被实例化的类，只能作为其他类的父类来使用。抽象类是通过关键字abstract来声明的。

抽象类与普通类相似，都包含成员变量和成员方法，两者的区别在于，抽象类中至少要包含一个抽象方法，抽象方法没有方法体，该方法天生就是要被子类重写的。

抽象方法的格式为：abstract function abstractMethod();

接口是通过 interface 关键字来声明的，接口中的成员常量和方法都是 public 的，方法可以不写关键字public，接口中的方法也是没有方法体。接口中的方法也天生就是要被子类实现的。

抽象类和接口实现的功能十分相似，最大的不同是接口能实现多继承。在应用中选择抽象类还是接口要看具体实现。

子类继承抽象类使用 extends，子类实现接口使用implements。

58.什么是队列？排它锁，Myisam死锁如何解决？

答:在默认情况下MYisam是表级锁，所以同时操作单张表的多个动作只能以队列的方式进行；

排它锁又名写锁，在SQL执行过程中为排除其它请求而写锁，在执行完毕后会自动释放；

死锁解决：先找到死锁的线程号，然后杀掉线程ID

59.bootstrap框架有哪些优点?

答:bootstrap是一款web开发框架,它由CSS,JavaScript,Html,三部分构成,它简洁灵活,使得web开发更加的快捷

优点:

①节省时间: 使用bootstrap框架,可以大大的节省项目开发时间,它包含了很多现成的代码,如果需要使用,只需要找到合适的代码,插入合适的位置即可,此外,CSS是使用LESS编写,很多样式和设计都已经设计完成了

②定制化: bootstrap可以根据自己的项目,留取框架中自己需要的部分

③设计合理:

栅格系统: bootstrap定义12格栅系统,在页面已经完成时,你可以根据合适的网格,以自己的需求改变行数和布局大小,样式已经开发完成了,只需要把代码放入合适的HTML代码位置即可

LESS: LESS是基于CSS之上的高级语言,其目的是使得CSS开发更加灵活,更加强大

JavaScript:bootstrap提供JavaScript库,该库超越了基本的架构和样式,开发者可以轻松的操作窗口警告框,工具提示框等,可避免了我们费神费力的写脚本

4.一致性: bootstrap可以保证界面在不同平台的统一性,无论实在IE,Chrome等

5.持续更新: bootstrap在不断的改进,更具规律性和持续性

6.响应式: 无论是在PC端还是移动端,都可以保持界面的一致性

7.文档多: bootstrap的非常多





1、什么事面向对象？主要特征是什么？
面向对象是程序的一种设计方式，它利于提高程序的重用性，使程序结构更加清晰。主要特征：封装、继承、多态。

2、SESSION 与 COOKIE的区别是什么，请从协议，产生的原因与作用说明?
A、http无状态协议，不能区分用户是否是从同一个网站上来的，同一个用户请求不同的页面不能看做是同一个用户。
B、SESSION存储在服务器端，COOKIE保存在客户端。Session比较安全，cookie用某些手段可以修改，不安全。Session依赖于cookie进行传递。
禁用cookie后，session不能正常使用。Session的缺点：保存在服务器端，每次读取都从服务器进行读取，对服务器有资源消耗。Session保存在服务器端的文件或数据库中，默认保存在文件中，文件路径由php配置文件的session.save_path指定。Session文件是公有的。

3、HTTP 状态中302、403、 500代码含义？
一二三四五原则:（即一：消息系列；二：成功系列； 三：重定向系列；四：请求错误系列；五：服务器端错误系列。）
302:临时转移成功，请求的内容已转移到新位置
403:禁止访问
500:服务器内部错误
401：代表未授权。

4、请写出数据类型(int char varchar datetime text)的意思；请问 varchar 和 char有什么区别？
Int 整数char 定长字符 Varchar 变长字符 Datetime 日期时间型Text 文本型 Varchar与char的区别 char是固定长度的字符类型，分配多少空间，就占用多长空间。Varchar是可变长度的字符类型，内容有多大就占用多大的空间，能有效节省空间。由于varchar类型是可变的，所以在数据长度改变的时，服务器要进行额外的操作，所以效率比char类型低。

5、MyISAM和 InnoDB 的基本区别？索引结构如何实现？
A、MyISAM类型不支持事务，表锁，易产生碎片，要经常优化，读写速度较快，适合用于频繁查询的应用；
B、InnoDB类型支持事务，行锁，有崩溃恢复能力，读写速度比MyISAM慢，适合于插入和更新操作比较多的应用，空间占用大，不支持全文索引等。
创建索引：alert table tablename add index 索引名 (`字段名`)

6、isset() 和 empty() 区别
sset判断变量是否存在，可以传入多个变量，若其中一个变量不存在则返回假；empty判断变量是否为空为假，只可传一个变量，如果为空为假则返回真。

（点击此处加入php高级交流群一起学习交流，11年架构师带你解读年薪50万面试通关秘籍。）

在这里我为PHP的同道者准备了架构相关视频资料

7、请说明 PHP 中传值与传引用的区别。什么时候传值什么时候传引用？
按值传递：函数范围内对值的任何改变在函数外部都会被忽略
按引用传递：函数范围内对值的任何改变在函数外部也能反映出这些修改
优缺点：按值传递时，php必须复制值。特别是对于大型的字符串和对象来说，这将会是一个代价很大的操作。按引用传递则不需要复制值，对于性能提高很有好处。

8、在PHP中error_reporting这个函数有什么作用？
设置PHP的报错级别并返回当前级别。

9、说说你对缓存技术的了解？
缓存技术是将动态内容缓存到文件中，在一定时间内访问动态页面直接调用缓存文件，而不必重新访问数据库。

10、现在编程中经常采取MVC三层结构，请问MVC分别指哪三层，有什么优点？
MVC三层分别指：业务模型、视图、控制器，由控制器层调用模型处理数据，然后将数据映射到视图层进行显示，优点是：①可以实现代码的重用性，避免产生代码冗余；②M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式

11、AJAX的优势是什么？
ajax是异步传输技术，可以通过javascript实现，也可以通过JQuery框架实现，实现局部刷新，减轻了服务器的压力，也提高了用户体验。

12、在程序的开发中，如何提高程序的运行效率？
A、优化SQL语句，查询语句中尽量不使用select *，用哪个字段查哪个字段；少用子查询可用表连接代替；少用模糊查询；
B、数据表中创建索引；
C、对程序中经常用到的数据生成缓存。

13、对于大流量的网站,您采用什么样的方法来解决访问量问题?
A、有效使用缓存，增加缓存命中率
B、使用负载均衡
C、对静态文件使用cdn进行存储和加速
D、想法减少数据库的使用
E、查看出现统计的瓶颈在哪里
F、反向代理

14、语句include和require的区别是什么?为避免多次包含同一文件，可用什么语句代替它们?
区别：
在失败的时候：
include产生一个warning，而require产生直接产生错误中断
require在运行前载入
include在运行时载入
代替：
require_once
include_once

15、foo()和@foo()之间有什么区别?
@代表所有warning忽略

16、简述php的垃圾收集机制。
答案：php中的变量存储在变量容器zval中，zval中除了存储变量类型和值外，还有is_ref和refcount字段。refcount表示指向变量的元素个数，is_ref表示变量是否有别名。如果refcount为0时，就回收该变量容器。如果一个zval的refcount减1之后大于0，它就会进入垃圾缓冲区。当缓冲区达到最大值后，回收算法会循环遍历zval，判断其是否为垃圾，并进行释放处理。

17、如何实现PHP的安全最大化？怎样避免SQL注入漏洞和XSS跨站脚本攻击漏洞？
答：基本原则：不对外界展示服务器或程序设计细节（屏蔽错误），不相信任何用户提交的数据（过滤用户提交）。

18、echo、print_r、print、var_dump区别
echo：语句结构；
print：是函数，有返回值
print_r：能打印数组，对象
var_dump:能打印对象数组，并且带数据类型

19、写出smarty模板的特点
速度快，编译型，缓存技术，插件机制，强大的表现逻辑

20、PHP如何实现页面跳转
方法一：php函数跳转，缺点，header头之前不能有输出，跳转后的程序继续执行，可用exit中断执行后面的程序。
header("Location:网址");//直接跳转
header("refresh:3;url=http://www.jsdaima.com");//三秒后跳转
方法二：利用meta
echo"";

21、如何把一个GB2312格式的字符串装换成UTF-8格式？
iconv('GB2312','UTF-8','js代码（www.jsdaima.com）是IT资源下载与IT技能学习平台。');
?>

22、如果需要原样输出用户输入的内容，在数据入库前，要用哪个函数处理？
htmlspecialchars或者htmlentities

23、什么是 CSRF 攻击 ？XSS 攻击？如何防范？
CSRF，跨站请求伪造，攻击方伪装用户身份发送请求从而窃取信息或者破坏系统。
讲述基本原理：用户访问A网站登陆并生成了cookie，再访问B网站，如果A网站存在CSRF漏洞，此时B网站给A网站的请求（此时相当于是用户访问），A网站会认为是用户发的请求，从而B网站就成功伪装了你的身份，因此叫跨站脚本攻击。

CSRF防范：
A、合理规范api请求方式，GET，POST
B、对POST请求加token令牌验证，生成一个随机码并存入session，表单中带上这个随机码，提交的时候服务端进行验证随机码是否相同。
XSS，跨站脚本攻击。
防范：不相信任何输入，过滤输入。

24、安全对一套程序来说至关重要，请说说在开发中应该注意哪些安全机制？
A、防远程提交；
B、防SQL注入，对特殊代码进行过滤；
C、防止注册机灌水，使用验证码。

25、对json数据格式的理解？
JSON(javascript object Notation)是一种轻量级的数据交换格式，json数据格式固定，可以被多种语言用作数据的传递。

26、什么是事务？及其特性？
答：事务：是一系列的数据库操作，是数据库应用的基本逻辑单位。

事务特性：
A、原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。
B、一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态
C、隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，
D、持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。

或者这样理解：
事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。

27、什么是锁？
答：数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。

加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。

基本锁类型：锁包括行级锁和表级锁

28、索引的作用？和它的优点缺点是什么？
答：索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。

29、如何通俗地理解三个范式？
第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；
第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；
第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。

30、主键、外键和索引的区别？
定义：
主键--唯一标识一条记录，不能有重复的，不允许为空
外键--表的外键是另一表的主键, 外键可以有重复的, 可以是空值
索引--该字段没有重复值，但可以有一个空值

作用：
主键--用来保证数据完整性
外键--用来和其他表建立联系用的
索引--是提高查询排序的速度

个数：
主键--主键只能有一个
外键--一个表可以有多个外键
索引--一个表可以有多个唯一索引

31、简述 private、 protected、 public修饰符的访问权限。
private : 私有成员, 在类的内部才可以访问。
protected : 保护成员，该类内部和继承类中可以访问。
public : 公共成员，完全公开，没有访问限制。

32、堆和栈的区别？
A、堆是程序运行期间动态分配的内存空间，你可以根据程序的运行情况确定要分配的堆内存的大小；
B、栈是编译期间就分配好的内存空间，因此你的代码中必须就栈的大小有明确的定义。

33、常用的魔术方法有哪些？举例说明
答：php规定以两个下划线（__）开头的方法都保留为魔术方法，所以建议大家函数名最好不用__开头，除非是为了重载已有的魔术方法。
__construct() 实例化类时自动调用。
__destruct() 类对象使用结束时自动调用。
__set() 在给未定义的属性赋值的时候调用。
__get() 调用未定义的属性时候调用。
__isset() 使用isset()或empty()函数时候会调用。
__unset() 使用unset()时候会调用。
__sleep() 使用serialize序列化时候调用。
__wakeup() 使用unserialize反序列化的时候调用。
__call() 调用一个不存在的方法的时候调用。
__callStatic()调用一个不存在的静态方法是调用。
__toString() 把对象转换成字符串的时候会调用。比如 echo。
__invoke() 当尝试把对象当方法调用时调用。
__set_state() 当使用var_export()函数时候调用。接受一个数组参数。
__clone() 当使用clone复制一个对象时候调用。

34、$this和self、parent这三个关键词分别代表什么？在哪些场合下使用？
$this 当前对象
self 当前类
parent 当前类的父类

$this在当前类中使用,使用->调用属性和方法
self也在当前类中使用，不过需要使用::调用
parent在类中使用

35、作用域操作符::如何使用？都在哪些场合下使用？
调用类常量
调用静态方法

36、__autoload()方法的工作原理是什么？
答：使用这个魔术函数的基本条件是类文件的文件名要和类的名字保持一致。

当程序执行到实例化某个类的时候，如果在实例化前没有引入这个类文件，那么就自动执行__autoload()函数。

这个函数会根据实例化的类的名称来查找这个类文件的路径，当判断这个类文件路径下确实存在这个类文件后

就执行include或者require来载入该类，然后程序继续执行，如果这个路径下不存在该文件时就提示错误。

使用自动载入的魔术函数可以不必要写很多个include或者require函数。

37、简述高并发网站解决方案。
A、前端优化（CND加速、建立独立图片服务器）
B、服务端优化（页面静态化、并发处理[异步|多线程]、队列处理）
C、数据库优化（数据库缓存[Memcachaed|Redis]、读写分离、分库分表、分区）
D、Web服务器优化（负载均衡、反向代理）


38、PHP遍历文件夹下所有文件

<?php
function read_all($dir){
  if(!is_dir($dir)) return false;
  $handle = opendir($dir);
  if($handle){
    while(($fl = readdir($handle)) !== false){
      $temp = $dir.$fl;
      //$fl !='.' && $fl != '..' 排除当前目录及父级目录
      if(is_dir($temp) && $fl!='.' && $fl != '..'){
        echo '目录：'.$temp.'<br>';
        read_all($temp);
      }else{
        if($fl !='.' && $fl != '..'){
          echo '文件：'.$temp.'<br>';
        }
      }
    }
  }
}
read_all("./dir/");
?>
复制代码

39、在命令行中运行php程序
php indx.php
A、从命令行运行php非常简单。但有些注意事项需要各位了解下，诸如$_SESSION之类的服务器变量是无法在命令行中使用的，其他代码的运行则和web服务器中完全一样；
B、在命令行中执行php文件的好处之一就是可以通过脚本实现一些计划任务（crontab）的执行，而无须通过web服务器。

延伸1：
php -v 显示当前PHP版本
php -m 显示当前php加载的有效模块
php -i 输出无html格式的phpinfo
php --rf function

延伸2：向php脚本传递参数：
提示：命令行下执行php，是不走Apache/Nginx等这类东西的，没有什么http协议，所以get,post传参数根本不起作用，并且还会报错。有些时候需要在shell命令下把PHP当作脚本执行，比如定时任务。这就涉及到在shell命令下如何给php传参的问题，通常有三种方式传参。

A、使用$argv or $argc参数接收
echo "接收到{$argc}个参数";
print_r($argv);
?>

B、使用getopt函数
$param_arr = getopt('a:b:');
print_r($param_arr);
?>

C、提示用户输入
fwrite(STDOUT,'Please enter your name：');
echo 'Your name is：'.fgets(STDIN);
?>

40、你用什么方法检查PHP脚本的执行效率（通常是脚本执行时间）和数据库SQL的效率（通常是数据库Query时间），并定位和分析脚本执行和数据库查询的瓶颈所在？
A、PHP脚本的执行效率
a、代码脚本里计时；
b、xdebug统计函数执行次数和具体时间进行分析，最好使用工具winCacheGrind分析；
c、在线系统用strace跟踪相关进程的具体系统调用。

B、数据库SQL的效率
a、sql的explain(mysql)，启用slow query log记录慢查询；
b、通常还要看数据库设计是否合理，需求是否合理等。

41、对于大流量的网站，您采用什么样的方法来解决各页面访问量统计问题。
A、确认服务器是否能支撑当前访问量；
B、优化数据库访问；
C、禁止外部访问链接（盗链）, 比如图片防盗链；
D、控制文件下载，尤其是大文件；
E、使用不同主机分流（负载均衡）；
F、使用浏览统计软件，了解访问量，有针对性的进行优化。

42、 MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？
A、设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率；
B、选择合适的表字段数据类型和存储引擎，适当的添加索引；
C、mysql库主从读写分离；
D、找规律分表，减少单表中的数据量提高查询速度；
E、添加缓存机制，比如memcached，redis等；
F、不经常改动的页面，生成静态页面；
G、书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。

43、Mysql的存储引擎,myisam和innodb的区别。
A、MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持；
B、MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快；
C、InnoDB不支持FULLTEXT类型的索引；
D、InnoDB中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可；
E、对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引；
F、DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除；
G、LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用；
H、MyISAM支持表锁，InnoDB支持行锁。

MyISAM：成熟、稳定、易于管理，快速读取。一些功能不支持（事务等），表级锁。
InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引等。



1.如何防止form表单重复提交？

2.Cookie被禁用了session还可以使用吗？

3.你了解的或者用过的版本控制工具有哪些？简单说明一下。

CVS,SVN, vss, git

4.单例模式的优点，如何实现？

5.单引号和双引号的区别是什么？

（1）双引号可以解析变量，单引号不能解析变量

（2）双引号和单引号可以互相嵌套

（3）双引号当中的变量可以使用特殊字符分隔开，但是特殊 字符会原样输出，使用{}不会输出

（4）双引号当中包含单引号，单引号当中包含变量，变量会被解析，单引号会被原样输出

（5）双引号可以解析转义字符，单引号不会解析转义字符，单引号只会解析本身和’单引号本身的转义

（6）单引号当中嵌套单引号，双引号当中嵌套双引号，当中的单引号和双引号需要使用转义符合

（7）单引号效率要高于双引号

6.对于大流量的网站，你采用什么样的方法来解决访问量问题？

7.MySQL数据库中的字段类型varchar和char的主要区别是什么？那种字段的查找效率要高，为什么？

8.说明echo（），var_dump（），print_r（）的区别。

9.请说明php中传值与传引用的区别。什么时候传值什么时候传引用？

10.说明Include，include_once，require，require_once的区别？

11.优化MYSQL数据库的方法。（4分，多写多得）

答：（1）选取最适用的字段属性，尽可能减少定义字段长度，尽量把字段设置NOT NULL,例如’省份，性别’,最好设置为ENUM。

（2）使用连接（JOIN）来代替子查询：

（3）使用联合（UNION）来代替手动创建的临时表

（4）事务处理：

（5）锁定表，优化事务处理：

（6）使用外键，优化锁定表

（7）建立索引：

（8）优化查询语句

12.如何优化查询语句，提高查询效率？

13.Session与cookie的区别？

14.Get和post的区别？

15.什么是mysql的事务？事务有哪些特性？

16.常用的超全局变量

$_GET ----->get传送方式

$POST ----->post传送方式

$REQUEST ----->可以接收到get和post两种方式的值

17.HTTP状态码

200 - 请求成功

301 - 资源（网页等）被永久转义到其他URL

404 - 请求的资源（网页等）不存在

505 - 内部服务器错误

1** - 信息，服务器收到的请求，需要请求者继续执行操作

2** - 成功，操作被成功接收并处理

3** - 重定向，需要进一步的操作以完成请求

4** - 客户端错误，请求包含语法错误或者无法完成请求

5** 服务器错误，服务器在处理请求的过程 中发生了错误

18.如何获取客户端的ip（要求取得一个int）和服务器ip的 代码

客户端：$_SERVER[“REMOTE_ADDR”];或者getenv（‘REMOTE_ADDR’）

服务器端：gethostbyname（‘www.baidu.com’）

19.写出三种以上MySQL数据库存储引擎的名称

MyISAM、InnoDB、BDB（BerkeleyDB）、Merge、Memory（Heap）、Example、Federated、

Archive、CSV、Blackhole、MaxDB 等等十几个引擎

20.使用过 Memcache 缓存吗，如果使用过，能够简单的描述一下它的工作原理

Memcahce 是把所有的数据保存在内存当中，采用 hash 表的方式，每条数据由 key 和 value 组成，每个 key 是独一无二的，当要访问某个值的时候先按照找到值，然后返回结果。

Memcahce 采用 LRU 算法来逐渐把过期数据清除掉

21.说明 Ajax 实现原理是什么及 json 在 Ajax 中起什么作用

Ajax 的工作原理是一个页面的指定位置可以加载另一个页面所有的输出内容，这样就实现了一个静态页面也能获取到数据库中的返回数据信息了。所以 Ajax 技术实现了一个静态网页在不刷新整个页面的情况下与服务器通信，减少了用户等待时间，同时也从而降低了网络流量，增强了客户体验的友好程度。

在使用 Ajax 时，涉及到数据传输，即将数据从服务器返回到客户端，服务器端和客户端分别使用不同的脚步语言来处理数据，这就需要一种通用的数据格式，XML 和 json 就是最常用的两种，而 json 比 XML 更简单

22.php中字符串处理函数列举3-6个

strlen（） 函数返回字符串的长度

strpos（） 函数用于检索字符串内指定的字符或文本

strtolower — 将字符串转变为小写

strtoupper –将字符串转变为大写

strtr — 对字符串比较替换

substr — 对字符串进行截取

explode — 将一个字符串用分割符转变为一数组形式

implode — 将数组用特定的分割符转变为字符串





1、__FILE__表示什么意思？（5分）

文件的完整路径和文件名。如果用在包含文件中，则返回包含文件名。自 PHP 4.0.2 起，__FILE__ 总是包含一个绝对路径，而在此之前的版本有时会包含一个相对路径。

2、如何获取客户端的IP地址？（5分）

$_SERVER[‘REMOTE_ADDR’]
3、写出使用header函数跳转页面的语句（5分）

Header(‘location:index.php’);
4、$str是一段html文本，使用正则表达式去除其中的所有js脚本（5分）

$pattern = ‘/<script.*>\.+<\/script>/’;

Preg_replace($pattern,’’,$str);
5、写出将一个数组里的空值去掉的语句（5分）

$arr = array(‘’,1,2,3,’’,19);
第一种方法:

$array1 = array(' ',1,'',2,3);

print_r(array_filter($array1, "del"));

function del($var)

{

return(trim($var));

}
第二种方法:

$arr=array("",1,2,3,"");

$ptn="/\S+/i";

print_r(preg_grep($ptn,$arr));
6、写出获取当前时间戳的函数，及打印前一天的时间的方法(格式：年-月-日 时:分:秒) （5分）

Time();

Date(“Y-m-d H:i:s”,Strtotime(“-1 day”));
7、写出php进行编码转换的函数（5分）

Iconv(‘utf-8’,’gb2312’,$str);
8、$str = “1,3,5,7,9,10,20”，使用什么函数可以把字符串str转化为包含各个数字的数组？（5分）

$arr = explode(“,”,$str);
9、serialize() /unserialize()函数的作用（5分）

serialize()和unserialize()在php手册上的解释是:

serialize — 产生一个可存储的值的表示，返回值为字符串，此字符串包含了表示 value 的字节流，不丢失其类型和结构，可以存储于任何地方。

unserialize — 从已存储的表示中创建 PHP 的值

具体用法：

$arr = array(“测试1″,”测试2″,”测试3″);//数组

$sarr = serialize($arr);//产生一个可存储的值(用于存储)
//用任意方法（例如：你要是吧$sarr存在一个文本文件中你就可以用file_get_contents取得）得到存储的值保存在$newarr中；

$unsarr=unserialize($newarr);//从已存储的表示中创建 PHP 的值
10、写出一个函数，参数为年份和月份，输出结果为指定月的天数（5分）

Function day_count($year,$month){

Echo date(“t”,strtotime($year.”-”.$month.”-1”));

}
11、一个文件的路径为/wwwroot/include/page.class.php，写出获得该文件扩展名的方法（5分）

$arr = pathinfo(“/wwwroot/include/page.class.php”);

$str = substr($arr[‘basename’],strrpos($arr[‘basename’],’.’));
12、你使用过哪种PHP的模板引擎？（5分）

Smarty,thinkphp自带的模板引擎

13、请简单写一个类，实例化这个类，并写出调用该类的属性和方法的语句（5分）

Class myclass{

Public $aaa;

Public $bbb;

Public function myfun(){

Echo “this is my function”;

}

}

$myclass = new myclass();

$myclass->$aaa;

$myclass->myfun();
14、本地mysql数据库db_test里已建有表friend，数据库的连接用户为root，密码为123

friend表字段为：id,name,age,gender,phone,email

请使用php连接mysql，选择出friend表里age > 20的所有记录打印结果，并统计出查询出的结果总数。（5分）

<?php

$link = Mysql_connect(“localhost”,”root”,”123”) or die(“数据库连接失败!”);

Mysql_select_db(“db_test”,$link) or die(“选择数据库失败!”);

$sql = “select id,name,age,gender,phone,email from friend where age>20”;

$result = mysql_query($sql);

$count = mysql_num_rows($result);

While($row = mysql_fetch_assoc($result)){

Echo $row[‘id’];

….

}
15、以下有两个表

user表 字段id (int)，name (varchar)

score表 字段uid (int)，subject (varchar) ，score (int)

score表的uid字段与user表的id字段关联

要求写出以下的sql语句

1）在user表里新插入一条记录，在score表里插入与新加入的记录关联的两条记录（5分）

2）获取score表里uid为2的用户score最高的5条记录（5分）

3）使用联合查询获取name为“张三”的用户的总分数（5分）

4）删除name为“李四”的用户，包括分数记录（5分）

5）清空score表（5分）

6）删除user表（5分）

1). mysql_query(“insert into user(name) values(‘test’)”);

$id = mysql_insert_id();

Mysql_query(“insert into score(uid,subjext,score) values(“.$id.”,’english’,’99’)”);

2).$sql = select uid,sunjext,score from score where uid=2 order by score desc limit 0,5;

3).select s.score from score s RIGHT JOIN user u ON u.id=s.uid where u.name=’张三;

4).delete from score where uid in(select id from user where name=’李四’);

Delete from user where name=’李四’;

5).delete from score;

6).drop table user;

\1. PHP方面的问题

​    什么是composer？以及composer是干什么用的？工作原理

​    Composer 是 PHP 的一个依赖管理工具，简单的说就是我们的项目通常会使用其它代码库，这时仅仅是在项目中申明依赖哪些代码库，默认情况下它不会在全局安装任何东西。

​    Composer的意义？

​    对于现代语言而言，依赖管理工具基本上是标配。Java 有 Maven，Python 有 pip，Ruby 有 gem，Nodejs 有 npm。PHP 的则是 PEAR，不过 PEAR 坑不少：依赖处理容易出问题，配置非常复杂，难用的命令行接口等等。

​    正是因为Composer的出现，解决了项目依赖的问题，并使PHP开发工作因此变得如同堆积木一般。

 

​    Packagist 是 Composer 的默认的开发包仓库。你可以将自己的安装包提交到 packagist，将来你在自己的 VCS （源码管理软件，比如 Github）仓库中新建了 tag 或更新了代码，packagist 都会自动构建一个新的开发包。这就是 packagist 目前的运作方式，将来 packagist 将允许直接上传开发包，发布自己的包。

​    PHP如何实现静态化

​      你了解设计模式吗？说下你最常用的设计模式

​      观察者模式是如何实现的？工厂模式是如何实现的？适配器模式是如何实现的？……

​      PHP的优化方案

​      说下你了解的session和cookie

​      如何实现不基于session和cookie的用户认证。

​      说下你目前框架所用到的核心概念

​      什么是CSRF攻击，XSS攻击？如何防范

​      你了解RESTful API吗？说说干什么用的。

​      设计的原则

​      如果实现自动加载？不用composer如何实现？PSR-4是什么？

\2. 数据库方面

- 你知道nosql吗？你用的nosql都有哪些？
- mysql索引优化
- mysql的优化方案
- mysql的事务
- mysql的读写分离
- 消息队列如何实现
- 查询优化
- msyql的存储引擎，以及各自的区别
- redis和memcache有什么区别
- 索引有哪些，你是如何做索引的？
- 如何分表

\3. 服务器方面

- 说下一些你常用的linux命令
- Linux如何搭建LAMP环境
- 你们平常工作的系统环境是在哪里？
- 你了解Docker吗？
- 你说下常用的服务端口号

\4. 前端知识

- 说下都有哪些跨域。
- 事件冒泡
- DOM事件流
- JS是如何实现继承的

\5. 算法和其它方面

- 最常用的排序算法
- 做一个微信抢红包的功能
- 如何防止高并发
- 你们用哪种版本控制？如何避免代码冲突
- 在浏览中输入网址后都发生了什么
- 你了解socket吗？


其它，必问知识

- 在项目中碰到的问题
- 是如何解决问题的
- 未来的规划是什么？
- 为什么离职
- 你的领导会如何评价你
- 你做得你公司最不错的项目，都用了哪些技术，带来哪些成长？
- TCP的三次握手，为什么三次，两次不行吗？为什么挥手又是四次

对程序员的建议：

- 一般面试的技术都是以后你要跟着他干的人员，所以多站在对方的场景下想问题，对方肯定是希望有个能帮他分担工作压力的人。
- 回答不要一问一答，最好能说出你自己的理解，以及它的优缺点。
- 一些技术方面的问题，要回答那些实用看的见的效果，比如composer可以解决自动加载类，不用你写过多的new。
- 技术不需要你全部会，但是要有自己的理解，这东西我没用过，但是我了解过一些，大概是什么，它是个啥技术，是为了解决啥技术。
- 对于面试的是技术的，不会就不会，没用过就没用过，如果你乱扯，技术一听就能听出来你说的对不对，但是你可以说说你对这个理解，这样就不至于冷场了，蒙对了加分，蒙错了也代表你会思考这个东西，会去想。

### 1. php 的垃圾回收机制

PHP 可以自动进行内存管理，清除不需要的对象。

PHP 使用了引用计数 (reference counting) GC 机制。

每个对象都内含一个引用计数器 refcount，每个 reference 连接到对象，计数器加 1。当 reference 离开生存空间或被设为 NULL，计数器减 1。当某个对象的引用计数器为零时，PHP 知道你将不再需要使用这个对象，释放其所占的内存空间。

参考 [http://www.php.net/manual/zh/features.gc.r...](https://link.zhihu.com/?target=http%3A//www.php.net/manual/zh/features.gc.refcounting-basics.php)

### 2. session 与 cookie 的区别和联系

区别：

\1. 存放位置：Session 保存在服务器，Cookie 保存在客户端。

\2. 存放的形式：Session 是以对象的形式保存在服务器，Cookie 以字符串的形式保存在客户端。

\3. 用途：Cookies 适合做保存用户的个人设置，爱好等，Session 适合做客户的身份验证

\4. 路径：Session 不能区分路径，同一个用户在访问一个网站期间，所有的 Session 在任何一个地方都可以访问到。而 Cookie 中如果设置了路径参数，那么同一个网站中不同路径下的 Cookie 互相是访问不到的。

\5. 安全性：Cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗，考虑到安全应当使用 session

\6. 大小以及数量限制：每个域名所包含的 cookie 数：IE7/8,FireFox:50 个，Opera30 个； Cookie 总大小：Firefox 和 Safari 允许 cookie 多达 4097 个字节，Opera 允许 cookie 多达 4096 个字 节，InternetExplorer 允许 cookie 多达 4095 个字节；一般认为 Session 没有大小和数量限制。

关系：

1. Session 需要借助 Cookie 才能正常工作。如果客户端完全禁止 Cookie，Session 将失效！因为 Session 是由应用服务器维持的一个 服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的 SessionID, 用该 SessionID 为标识符来存取服务器端的 Session 存储空间。而 SessionID 这一数据则是保存到客户端，用 Cookie 保存的，用户提交页面时，会将这一 SessionID 提交到服务器端，来存取 Session 数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用 Cookie，那么 Session 也会失效。

### 3. 如何修改 SESSION 的生存时间

1. 设置浏览器保存的 sessionid 失效时间 setcookie (session_name (), session_id (), time () + $lifeTime, "/");
2. 可以使用 SESSION 自带的 session_set_cookie_params (86400); 来设置 Session 的生存期
3. 通过修改 php.ini 中的 session.gc_maxlifetime 参数的值就可以改变 session 的生存时间



### 4. PHP 页面重定向的方法有哪些

1. header('Location: [baidu.com/](https://link.zhihu.com/?target=http%3A//www.baidu.com/)') ;
2. echo '';

​    3 echo '';

### 5. PDO、adoDB、PHPLib 数据库抽象层比较

PHP 数据库抽象层就是指，封装了数据库底层操作的介于 PHP 逻辑程序代码和数据库之间的中间件。

PDO 以 PHP 5.1 为基础进行设计，它使用 C 语言做底层开发，设计沿承 PHP 的特点，以简洁易用为准，从严格意义上讲，PDO 应该归为 PHP 5 的 SPL 库之一，而不应该归于数据抽象层，因为其本身和 MySQL 和 MySQLi 扩展库的功能类似。PDO 是不适合用在打算或者有可能会变更数据库的系 统中的。

ADODB 不管后端数据库如何，存取数据库的方式都是一致的；

转移数据库平台时，程序代码也不必做太大的更动，事实上只需要改动数据库配置文 件。提供了大量的拼装方法，目的就是针对不同的数据库在抽象层的底层对这些语句进行针对性的翻译，以适应不同的数据库方言！但是这个抽象层似乎体积过于庞 大了，全部文件大概有 500K 左右，如果你做一个很小的网站的话，用这个似乎大材小用了

PHPLib 可能是伴随 PHP 一同成长最老的数据库抽象层（但和 ADODB 相比，它只算是一个 MySQL 抽象类库），这个抽象类使用方法相当简单，体积小，是小型网站开发不错的选择。

PDO 提供预处理语句查询、错误异常处理、灵活取得查询结果（返回数组、字符串、对象、回调函数）、字符过滤防止 SQL 攻击、事务处理、存储过程。

ADODB 支持 缓存查询、移动记录集、（HTML、分页、选择菜单生成）、事务处理、输出到文件。 参考 [http://apps.hi.baidu.com/share/detail/4636...](https://link.zhihu.com/?target=http%3A//apps.hi.baidu.com/share/detail/463678)



### 6. 长连接、短连接的区别和使用

长连接：client 方与 server 方先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。此种方式常用于 P2P 通信。

短连接：Client 方与 server 每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。C/S 通信。

长连接与短连接的使用时机：

长连接：

短连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。每个 TCP 连 接的建立都需要三次握手，每个 TCP 连接的断开要四次握手。如果每次操作都要建立连接然后再操作的话处理速度会降低，所以每次操作下次操作时直接发送数据 就可以了，不用再建立 TCP 连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成 socket 错误，频繁的 socket 创建也是对资源的浪 费。

短连接：

web 网站的 http 服务一般都用短连接。因为长连接对于服务器来说要耗费一定 的资源。像 web 网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。试想如果都用长连接，而且同时用成千上万的用户，每个用户都占有一个 连接的话，可想而知服务器的压力有多大。所以并发量大，但是每个用户又不需频繁操作的情况下需要短连接。

参考 [cnblogs.com/Roberts/arc](https://link.zhihu.com/?target=http%3A//www.cnblogs.com/Roberts/archive/2010/12/05/1986550.html)



### 7. HTTP 协议详解、应用

http（超文本传输协议）是一个基于请求与响应模式的、无状态的、短连接、灵活、应用层的协议，常基于 TCP 的连接方式。

参考 [http://blog.csdn.net/gueter/article/detail...](https://link.zhihu.com/?target=http%3A//blog.csdn.net/gueter/article/details/1524447) (http 协议详解)

(HTTP 响应状态码)

HTTP 响应状态码

状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：

1xx：指示信息 -- 表示请求已接收，继续处理

2xx：成功 -- 表示请求已被成功接收、理解、接受

3xx：重定向 -- 要完成请求必须进行更进一步的操作

4xx：客户端错误 -- 请求有语法错误或请求无法实现

5xx：服务器端错误 -- 服务器未能实现合法的请求

常见状态代码、状态描述、说明：

200 OK // 客户端请求成功

400 Bad Request // 客户端请求有语法错误，不能被服务器所理解

401 Unauthorized // 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用 403 Forbidden // 服务器收到请求，但是拒绝提供服务

404 Not Found // 请求资源不存在，eg：输入了错误的 URL

500 Internal Server Error // 服务器发生不可预期的错误

503 Server Unavailable // 服务器超时 // 可能恢复正常

304 Not Modifed // 自从上次请求后，请求的网页未修改过。

// 服务器返回此响应时，不会返回网页内容。



### 8. 异构系统通讯中的通讯加密方案

参考 [http://blog.csdn.net/linvo/article/details...](https://link.zhihu.com/?target=http%3A//blog.csdn.net/linvo/article/details/5741942)



### 9. socket 连接步骤

Socket（套接字）概念

套接字（socket）是通信的基石，是支持 TCP/IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的 IP 地址，本地进程的协议端口，远地主机的 IP 地址，远地进程的协议端口。

Socket 连接过程

建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ，另一个运行于服务器端，称为 ServerSocket

套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认。

服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。

客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端

套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。



### 10. TCP 协议，三次握手、四次挥手

TCP 协议 (Transmission Control Protocol) 是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接，四次挥手断开连接。

位码即 tcp 标志位，有 6 种标示:

SYN (synchronous 建立联机) 同步

ACK (acknowledgement 确认)

PSH (push 传送)

FIN (finish 结束)

RST (reset 重置)

URG (urgent 紧急)



### 11. php 中常用作用相似，性能差异很大的函数区分及举例

参考 [http://apps.hi.baidu.com/share/detail/4316...](https://link.zhihu.com/?target=http%3A//apps.hi.baidu.com/share/detail/43169774)



### 12. posix 及 perl 兼容正则比较，及函数性能分析

POSIX 正则和 PCRE 正则最显著的需要知道的不同点：

1. PCRE 函数需要模式以分隔符闭合.
2. POSIX 兼容正则没有修正符。不像 POSIX, PCRE 扩展没有专门用于大小写不敏感匹配的函数。取而

代之的是，支持使用 /i 模式修饰符完成同样的工作。其他模式修饰符同样可用于改变匹配策略.

1. POSIX 函数从最左面开始寻找最长的匹配，但是 PCRE 在第一个合法匹配后停止。如果字符串 不匹

配这没有什么区别，但是如果匹配，两者在结果和速度上都会有差别。为了说明这个不同，考虑下面的例子 (来自 Jeffrey Friedl 的《精通正则表达式》一书). 使用模式 one (self)?(selfsufficient)? 在字符串 oneselfsufficient 上匹配，PCRE 会匹配到 oneself, 但是使用 POSIX, 结果将是整个字符串 oneselfsufficient. 两个子串都匹配原始字符串，但是 POSIX 将 最长的最为结果.

PCRE 可用的修饰符: (i,s,m)



### 13. 实现 PERL 正则表达式，抓取 html 文件 a 标签的所有 href 超链接

正则：/<a\s+.*?href=[\'\"](.*?)[\'\" >]/is

$html = <<<HTML

HTML;

$matches = array();

preg_match_all ( "/<a\s+.*?href=[\'\"](.*?)[\'\">]/is", $html, $matches ); print_r ($matches [1]); // 输出所有超链接

?>



### 14. 预定义变量、魔术变量、魔术方法比较，及作用举例

预定义变量（超级全局变量）

$GLOBALS

$_SERVER

$_GET

$_POST

$_COOKIE

$_SESSION

$_REQUEST

$_ENV

魔术方法 [apps.hi.baidu.com/share](https://link.zhihu.com/?target=http%3A//apps.hi.baidu.com/share/detail/17851228)

construct 和 destruct

__autoload

get 和 set

isset 和 unset

call 和 callStatic

__clone

__toString

sleep 和 wakeup

__invoke

魔术变量 [apps.hi.baidu.com/share](https://link.zhihu.com/?target=http%3A//apps.hi.baidu.com/share/detail/17851228)

LINE

FILE

DIR

CLASS

FUNCTION

METHOD

NAMESPACE



### 15. spl 常用数据结构类



### 16. PHP 设计模式

工厂模式

建立一个工厂（一个函数或一个类方法）来制造新的对象

工厂模式 是一种类，它具有为您创建对象的某些方法。您可以使用工厂类创建对象，而不直接使用 new。这样，如果您想要更改所创建的对象类型，只需更改该工厂即可。使用该工厂的所有代码会自动更改。

单例模式

某些应用程序资源是独占的，因为有且只有一个此类型的资源。例如，通过数据库句柄到数据库的连接是独占的。您希望在应用程序中共享数据库句柄，因为在保持连接打开或关闭时，它是一种开销，在获取单个页面的过程中更是如此。

单元素模式可以满足此要求。

PHP 中的单例模式（singleton pattern）：指的是在 PHP 的应用程序的范围内只对指定的类创建一个实例。

在 PHP 中使用单例模式的类通常拥有一个私有构造函数和一个私有克隆函数，以防 止用户通过创建对象或者克隆对其进行实例化。还有一个静态私有成员变量 $instance 与静态方法 getInstance。getInstance 负责对其本身实例化，然后将这个对象存储在 $instance 静态成员变量中，以确保只有一个实例被创建。

观察者模式

命令链模式

策略模式



### 17. 负载均衡的 web 应用服务器设计，例如 youku

用 PHP 做负载均衡指南

思考如何应对以下问题？ 参考 [examw.com/linux/all/142](https://link.zhihu.com/?target=http%3A//www.examw.com/linux/all/142494/)

在 Apache 负载均衡的情况下，做 PHP 开发如何考虑一下几方面：

PHP 源文件在服务器、PHP 文件上传处理、相关配置文件、Session 会话放置、日志放置

Apache 负载均衡的原则：

参考 [s456123123b.blog.163.com](https://link.zhihu.com/?target=http%3A//s456123123b.blog.163.com/blog/static/5632332220101080474642/)

轮询均衡策略 （轮询转发请求）

按权重分配均衡策略 （按响应数量转发请求）

权重请求响应负载均衡策略 （按响应流量转发请求）



### 18. 如何优化前端性能

1) 页面内容的优化

a) 降低请求数

合并 css、js 文件，集成 CSS 图片

b) 减少交互通信量

压缩技术：压缩 css、js 文件，优化图像，减少 cookie 体积；

合理利用缓存：使用外部 js/css 文件，缓存 ajax；

减少不必要的通信量：剔除无用脚本和样式、推迟加载内容、使用 GET 请求

c) 合理利用 “并行” 尽量避免重定向

慎用 Iframe 样式表置于顶部 脚本放到样式后面加载

d) 节约系统消耗

避免 CSS 表达式、滤镜

2) 服务器的优化

a) b)

c)

d)



### 19. yahoo 的 34 条前端优化法则

减少 HTTP 请求、利用 CDN 技术、 设置头文件过期或者静态缓存、Gzip 压缩、把 CSS 放顶部、 把 JS 放底部、避免 CSS 表达式、将 JS 和 CSS 外链、减少 DNS 查找、减小 JS 和 CSS 的体积、 避免重定向、删除重复脚本、 配置 ETags、缓存 Ajax、尽早的释放缓冲、

用 GET 方式进行 AJAX 请求、延迟加载组件、 预加载组件、减少 DOM 元素数量、跨域分离组件、

减少 iframe 数量、不要出现 404 页面、减小 Cookie、 对组件使用无 Cookie 的域名、减少 DOM 的访问次数、开发灵活的事件处理句柄、使用 <link> 而非 @import、避免过滤器的使用、优化图片、优化 CSS Sprites、 不要在 HTML 中缩放图片、缩小 favicon. ico 的大小并缓存它、保证组件在 25K 以下、将组件打包进一个多部分的文档中



### 20. 数据库缓存的基本理论，参考 memcached

什么是 Memcached？

memcached 是高性能的分布式内存缓存服务器。一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态 Web 应用的速度、提高可扩展性。

虽然 memcached 使用了同样的 “Key=>Value” 方式组织数据，但是它和共享内存、APC 等本地缓存有非常大的区别。Memcached 是分布式的，也就是说 它不是本地的。它基于网络连接（当然它也可以使用 localhost）方式完成服务，本身它是一个独立于应用的程序或守护进程（Daemon 方式）

PHP 与 Memcached

Memcached 使用 libevent 库实现网络连接服务，理论上可以处理无限多的连接，但是它和

基于反向代理的 Web 缓存；

基于反向代理的 Web 缓存



### 23. PHP 安全模式

php 安全模式：safe_mode=on|off

启用 safe_mode 指令将对在共享环境中使用 PHP 时可能有危险的语言特性有所限制。可以将 safe_mode 是指为布尔值 on 来启用，或者设置为 off 和脚本尝试访问的文件的 UID，以此作为限制机制的基础。如果 UID 相同，则执行脚本；否则，脚本失败。

当启用安全模式时，一些限制将生效

1、 所有输入输出函数（例如 fopen ()、file () 和 require ()）的适用会受到限制，只能用于与调用这些函数的

脚本有相同拥有者的文件

2、 如果试图通过函数 popen ()、system () 或 exec () 等执行脚本，只有当脚本位于 safe_mode_exec_dir

配置指令指定的目录才可能

3、HTTP 验证得到进一步加强，因为验证脚本用于者的 UID 划入验证领域范围内。此外，当启用安

全模式时，不会设置 PHP_AUTH。

4、如果适用 MySQL 数据库服务器，链接 MySQL 服务器所用的用户名必须与调用 mysql_connect ()

的文件拥有者用户名相同。

以下是一些和安全模式相关的配置选项

safe_mode_gid=on|off

safe_mode_include_dir=string

safe_mode_env_vars=string

safe_mode_exec_dir=string

safe_mode_protected_env_vars=string



### 24. 常见的 web 攻击方式

常见攻击

XSS (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览该页之时，嵌入的恶意 html 代码会被执行，从而达到恶意用户的特殊 目的。XSS 属于被动式的攻击，因为其被动且不好利用，所以许多人常呼略其危害性。但是随着前端技术的不断进步富客户端的应用越来越多，这方面的问题越来 越受关注。举个简单例子 ： 假如你现在是 sns 站点上一个用户，发布信息的功能存在漏洞可以执行 js 你在 此刻输入一个 恶意脚本，那么当前所有看到你新信息的人的浏览器都会执行这个脚本弹出提示框 （很爽吧 弹出广告 ：）），如果你做一些更为激进行为呢 后果难以想象。

CSRF (Cross Site Request Forgery)，跨站点伪造请求。顾名思义就是 通过伪造连接请求在用户不知情的情况下，让用户以自己的身份来完成攻击者需要达到的一些目的。csrf 的攻击不同于 xss csrf 需要被攻击者的主动行为触发。这样听来似乎是有 “被钓鱼” 的嫌疑。

多窗口浏览器这这方面似乎是有助纣为虐的嫌疑，因为打开的新窗口是具有当前所有 会话的，如果是单浏览器窗口类似 ie6 就不会存在这样的问题，因为每个窗口都是一个独立的进程。举个简单例子 ： 你正在玩白社会， 看到有人发了一个连接，你点击过去，然后这个连接里面伪造了一个送礼物的表单，这仅仅是一个简单的例子，问题可见一般。

cookie 劫持。通过获取页面的权限，在页面中写一个简单的到恶意站点的请 求，并携带用户的 cookie 获取 cookie 后通过 cookie 就可以直以被盗用户的身份登录站点。这就是 cookie 劫持。举个简单例子： 某人写了一篇很有意思的日志，然后分享给大家，很多人都点击查看并且分享了该日志，一切似乎都很正常，然而写日志的人却另有用心，在日志中偷偷隐藏了一个 对站外的请求，那么所有看过这片日志的人都会在不知情的情况下把自己的 cookie 发送给了 某人，那么他可以通过任意一个人的 cookie 来登录这个人的账户。

SQL 注入攻击

在 SQL 注入攻击 中，用户通过操纵表单或 GET 查询字符串，将信息添加到数据库查询中。

DNS 攻击

拒绝服务攻击

拒绝服务攻击即攻击者想办法让目标机器停止提供服务，是黑客常用的攻击手段之。

攻击者进行拒绝服务攻击，实际上让服务器实现两种效果：一是迫使服务器的缓冲区满，不接收新的请求；二是使用 IP 欺骗，迫使服务器把合法用户的连接复位，影响合法用户的连接



### 25. PHP 做好防盗链的基本思想 防盗链

什么是盗链？

盗链是指服务提供商自己不提供服务的内容，通过技术手段绕过其它有利益的最终用户界面 (如广告)，直接在自己的网站上向最终用户提供其它服务提供商的服务内容，骗取最终用户的浏览和点击率。受益者不提供资源或提供很少的资源，而真正的服务提供商却得不到任何的收益。

网站盗链会大量消耗被盗链网站的带宽，而真正的点击率也许会很小，严重损害了被盗链网站的利益。 如何做防盗链？

不定期更名文件或者目录

限制引用页

原理是，服务器获取用户提交信息的网站地址，然后和真正的服务端的地址相比较， 如果一致则表明是站内提交，或者为自己信任的站点提交，否则视为盗链。实现时可以使用 HTTP_REFERER1 和 htaccess 文件 (需要启用 mod_Rewrite)，结合正则表达式去匹配用户的每一个访问请求。

文件伪装

文件伪装是目前用得最多的一种反盗链技术，一般会结合服务器端动态脚本 (PHP/JSP/ASP)。实际上用户请求的文件地址，只是一个经过伪装的脚本文件，这个脚本文件会对用户的请求作认证，一般会检查 Session，Cookie 或 HTTP_REFERER 作为判断是否为盗链的依据。而真实的文件实际隐藏在用户不能够访问的地方，只有用户通过验证以后才会返回给用户

加密认证

这种反盗链方式，先从客户端获取用户信息，然后根据这个信息和用户请求的文件名 字一起加密成字符串 (Session ID) 作为身份验证。只有当认证成功以后，服务端才会把用户需要的文件传送给客户。一般我们会把加密的 Session ID 作为 URL 参数的一部分传递给服务器，由于这个 Session ID 和用户的信息挂钩，所以别人就算是盗取了链接，该 Session ID 也无法通过身份认证，从而达到反盗链的目的。这种方式对于分布式盗链非常有效。

随机附加码

每次，在页面里生成一个附加码，并存在数据库里，和对应的图片相关，访问图片时和此附加码对比，相同则输出图片，否则输出 404 图片

加入水印



### 26. HTTP 请求头信息和响应头信息

请求头信息

POST /scp1.1.0/prs/new_rnaseqtask/run_go HTTP/1.1

Host: 172.30.4.102

User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:6.0) Gecko/20100101 Firefox/6.0

Accept: */*

Accept-Language: zh-cn,zh;q=0.5

Accept-Encoding: gzip, deflate

Accept-Charset: GB2312,utf-8;q=0.7,*;q=0.7

Connection: keep-alive

Content-Type: application/x-www-form-urlencoded; charset=UTF-8

X-Requested-With: XMLHttpRequest

Referer: [http://172.30.4.102/scp1.1.0/index.php/prs...](https://link.zhihu.com/?target=http%3A//172.30.4.102/scp1.1.0/index.php/prs/new_rnaseqtask/index_continue/13/364) Content-Length: 1819

Cookie:

ci_session=a%3A4%3A%7Bs%3A10%3A%22session_id%22%3Bs%3A32%3A%22e31556053ff9407a454f6a1e146d43eb%22%3Bs%3A10%3A%22ip_address%22%3Bs%3A12%3A%22172.16.23.42%22%3Bs%3A10%3A%22user_agent%22%3Bs%3A50%3A%22Mozilla%2F5.0+%28Windows+NT+6.1%3B+rv%3A6.0%29+Gecko%2F2010010%22%3Bs%3A13%3A%22last_activity%22%3Bi%3A1314955607%3B%7D664b51a01ef99bac95f3e2206e79cb00;PHPSESSID=v33mlm1437lmop1fquta675vv4;username=linjinming; tk=1314955601855 Pragma: no-cache

Cache-Control: no-cache

响应头信息

HTTP/1.1 200 OK

Date: Fri, 02 Sep 2011 09:27:07 GMT

Server: Apache/2.2.3 (Red Hat)

X-Powered-By: PHP/5.1.6

Expires: Thu, 19 Nov 1981 08:52:00 GMT

Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0

Pragma: no-cache

Vary: Accept-Encoding

Content-Encoding: gzip

Content-Length: 31

Connection: close

Content-Type: text/html; charset=UTF-8



### 27. MySQL

MySQL 数据库性能优化

使用 mysqlreport；

正确使用索引：explain 分析查询语句，组合索引，索引副作用（占空间、update）

开启慢查询日志、使用慢查询分析工具 mysqlsla；

索引缓存、索引代价（插入更新索引）；

表锁，行锁，行锁副作用（update 多时候变慢），在 select 和 update 混合的情况下，行锁巧妙解决了读写互斥的问题；

开启使用查询缓存；

修改临时表内存空间；

开启线程池；

MySQL Query 语句优化的基本思路和原则

1. 优化需要优化的 Query；
2. 定位优化对象的性能瓶颈；
3. 明确优化目标；
4. 从 Explaing 入手；
5. 多使用 Profile；
6. 永远用小结果集推动大的结果集；
7. 尽可能在索引中完成排序；
8. 只取自己需要的 Columns；
9. 仅仅使用最有效的过滤条件；
10. 尽可能避免复杂的 Join 和子查询。

MySQL 中 MyISAM 引擎和 InnoDB 引擎的区别以及它们的性能

1：Innodb 支持事物，Myisam 不支持

2：锁定机制不一样，Myisam 支持表锁定，而 Innodb 支持行锁

3：Myisam 不支持外键，Innodb 能支持

4：Myisam 能在特定环境下支持全文索引，而 Innodb 不支持

5：Myisam 支持数据压缩，Innodb 不支持

6：在数据存储上，Myisam 占用的空间少，Innodb 相对多些

7：Myisam 在批量插入和查询方面速度上有优势，而 Innodb 由于支持行锁，所以在数据修改方面更胜一筹

MySQL 存储引擎

MyISAM：不支持事务、表锁和全文索引，操作速度快

InnoDB：行锁设计、支持外键、支持安全事务

HEAP：数据存放在内存中，临时表

NDB Cluster：MySQL 的簇式数据库引擎

CSV: 存储引擎把数据以逗号分隔的格式存储在文本文件中。

FEDERATED：存储引擎表并不存放数据，它只是指向一台远程 MySQL 数据库服务器上的表 Archive: 只支持 INSERT 和 SELECT 操作，压缩后存储，非常适合存储归档数据

Merge：允许将一系列等同的 MyISAM 表以逻辑方式组合在一起，并作为 1 个对象引用它们 表类型，区分表类型

优化表设计的常用思路

负载均衡的数据库设计

数据类型及详细定义，区分



### 28. Apache

性能优化，配置，fastCGI 等几种工作模式



### 29. Ajax

用 JS 实现 Ajax 功能

```
var createXHR = function(){

}

var addURLParam = function(url, name, value){

}

var xhr = createXHR();

xhr.onreadystatechange = function(){

}

var url = 'testAjax.php';

addURLParam(url, 'name', 'linjm');

xhr.open('get',url,true);

xhr.send(NULL);

if(xhr.readyState == 4){    } if(xhr.status > 200 && xhr.status < 300 || xhr.status == 304){  } alert(xhr.responseText); url += (url.indexOf('?') == -1 ? '?' : '&'); url += encodeURIComponent(name) + '=' + encodeURIComponent(value); return url; if(window.XMLHttpRequest){    } return new XMLHttpRequest(); return new ActiveXObject('Microsoft.XMLHTTP'); throw new Error('No XMLHttpRequest available'); }else{ }else{}
```

### 30. Javascript

变量、作用域、作用域链

 

\1. 数据库设计经验，为什么进行分表？分库？一般多少数据量开始分表？分库？分库分表的目的？什么是数据库垂直拆分？水平拆分？分区等等

一：为什么要分表

当一张表的数据达到几百万时，你查询一次所花的时间会变多，如果有联合查询的话，有可能会死在那儿了。分表的目的就在于此，减小数据库的负担，缩短查询时间。日常开发中我们经常会遇到大表的情况，所谓的大表是指存储了百万级乃至千万级条记录的表。这样的表过于庞大，导致数据库在查询和插入的时候耗时太长，性能低下，如果涉及联合查询的情况，性能会更加糟糕。分表和表分区的目的就是减少数据库的负担，提高数据库的效率，通常点来讲就是提高表的增删改查效率。数据库中的数据量不一定是可控的，在未进行分库分表的情况下，随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，相应地，数据操作，增删改查的开销也会越来越大；另外，由于无法进行分布式式部署，而一台服务器的资源（CPU、磁盘、内存、IO 等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。

二：分表的方案

1，做 mysql 集群，有人会问 mysql 集群，根分表有什么关系吗？虽然它不是实际意义上的分表，但是它启到了分表的作用，做集群的意义是什么呢？为一个数据库减轻负担，说白了就是减少 sql 排队队列中的 sql 的数量，举个例子：有 10 个 sql 请求，如果放在一个数据库服务器的排队队列中，他要等很长时间，如果把这 10 个 sql 请求，分配到 5 个数据库服务器的排队队列中，一个数据库服务器的队列中只有 2 个，这样等待时间是不是大大的缩短了呢？

linux mysql proxy 的安装，配置，以及读写分离

mysql replication 互为主从的安装及配置，以及数据同步

优点：扩展性好，没有多个分表后的复杂操作（php 代码）

缺点：单个表的数据量还是没有变，一次操作所花的时间还是那么多，硬件开销大。

\2. 垂直分割就是按字段分。水平分割。就是按记录分

\2. 数据库优化有哪些？分别需要注意什么？

SQL 优化的原则是：将一次操作需要读取的 BLOCK 数减到最低，即在最短的时间达到最大的数据吞吐量。

调整不良 SQL 通常可以从以下几点切入：

检查不良的 SQL，考虑其写法是否还有可优化内容

检查子查询 考虑 SQL 子查询是否可以用简单连接的方式进行重新书写

检查优化索引的使用

考虑数据库的优化器

避免出现 SELECT * FROM table 语句，要明确查出的字段。

在一个 SQL 语句中，如果一个 where 条件过滤的数据库记录越多，定位越准确，则该 where 条件越应该前移。

查询时尽可能使用索引覆盖。即对 SELECT 的字段建立复合索引，这样查询时只进行索引扫描，不读取数据块。

在判断有无符合条件的记录时建议不要用 SELECT COUNT （）和 select top 1 语句。

使用内层限定原则，在拼写 SQL 语句时，将查询条件分解、分类，并尽量在 SQL 语句的最里层进行限定，以减少数据的处理量。

应绝对避免在 order by 子句中使用表达式。

如果需要从关联表读数据，关联的表一般不要超过 7 个。

小心使用 IN 和 OR，需要注意 In 集合中的数据量。建议集合中的数据不超过 200 个。

<> 用 < 、> 代替，> 用 >= 代替，< 用 <= 代替，这样可以有效的利用索引。

在查询时尽量减少对多余数据的读取包括多余的列与多余的行。

对于复合索引要注意，例如在建立复合索引时列的顺序是 F1，F2，F3，则在 where 或 order by 子句中这些字段出现的顺序要与建立索引时的字段顺序一致，且必须包含第一列。只能是 F1 或 F1，F2 或 F1，F2，F3。否则不会用到该索引。

多表关联查询时，写法必须遵循以下原则，这样做有利于建立索引，提高查询效率。格式如下

select sum（table1.je） from table1 table1, table2 table2, table3 table3 where (table1的等值条件（=）) and(table1的非等值条件) and (table2与table1的关联条件) and (table2的等值条件) and (table2的非等值条件) and(table3与table2的关联条件) and (table3的等值条件) and (table3的非等值条件)。

注：关于多表查询时 from 后面表的出现顺序对效率的影响还有待研究。

子查询问题。对于能用连接方式或者视图方式实现的功能，不要用子查询

在 WHERE 子句中，避免对列的四则运算，特别是 where 条件的左边，严禁使用运算与函数对列进行处理。比如有些地方 substring 可以用 like 代替。

如果在语句中有 not in（in）操作，应考虑用 not exists（exists）来重写，最好的办法是使用外连接实现。

对一个业务过程的处理，应该使事物的开始与结束之间的时间间隔越短越好，原则上做到数据库的读操作在前面完成，数据库写操作在后面完成，避免交叉。

请小心不要对过多的列使用列函数和 order by,group by 等，谨慎使用 disti 软件开发 t。

用 union all 代替 union，数据库执行 union 操作，首先先分别执行 union 两端的查询，将其放在临时表中，然后在对其进行排序，过滤重复的记录。

当已知的业务逻辑决定 query A 和 query B 中不会有重复记录时，应该用 union all 代替 union，以提高查询效率。

20、选取最适用的字段属性 ，MySQL 可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。

例如，在定义邮政编码这个字段时，如果将其设置为 CHAR (255), 显然给数据库增加了不必要的空间，甚至使用 VARCHAR 这种类型也是多余的，因为 CHAR (6) 就可以很好的完成任务了。同样的，如果可以的话，我们应该使用 MEDIUMINT 而不是 BIGIN 来定义整型字段。

另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为 NOTNULL，这样在将来执行查询的时候，数据库不用去比较 NULL 值。

对于某些文本字段，例如 “省份” 或者 “性别”，我们可以将它们定义为 ENUM 类型。因为在 MySQL 中，ENUM 类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。

\3. web 开发方面会遇到哪些缓存？分别如何优化？

浏览器缓存

在任何现代浏览器上 (如 IE, FireFox, Chrome) 折腾清除隐私数据的对话框，你很可能会注意到 “缓存” 这个设置项。

代理服务器缓存

Web 代理服务器使用同样的缓存原理，只是规模更大。代理以同样的方式服务千万用户，大公司和 ISP 经常在他们的防火墙或者单独的设备（也被称为中介 (intermediaries)）上架设代理缓存。

网关缓存

也被称为 “反向代理缓存” 或 “替代缓存”。网关缓存同样是起中介作用的，不过不是网络管理员部署的，而多半是网站管理员（公司专门的运维工程师、或 UED 或程序组某人 Add）部署，这样更容易扩展与维护。

\4. 给你 256M 的内存，统计 10G 文件每个关键字出现的次数如何实现？![img](http://leanote.daiem.cn/file/outputImage?fileId=5eae39e2e138231bfb000046)

![img](https://note.daiem.cn/api/file/getImage?fileId=5eae3a33e138231bfb000047)

思路

$handle=fopen("/tmp/uploadfile.txt","r")ordie("Couldn't get handle");if($handle){while(!feof($handle)){$buffer=fgets($handle,4096);// Process buffer here..}fclose($handle);}

\5. PHP 的生命周期 / 启动流程

完整的生命周期为模块初始化、请求初始化、请求处理、请求关闭、模块关闭五大阶段。

cli 模式下，每个脚本都会完整的执行上面的五大阶段；对于 fastcgi 模式而言，只在启动时会执行模块初始化，之后的请求都走了请求初始化、处理请求、请求关闭三大阶段，在 fastcgi 关闭时执行模块关闭阶段。各个扩展的加载也是在模块初始化阶段完成的。

\6. 说一下 PHP 的（内存）垃圾回收机制

每一个变量对应一个 zval 数据结构，在该结构内还有一个 val 结构体，该结构体内有一个引用计数（php7 而言，对于 php5，这个引用计数是保存在 zval 结构中的），标识该对象的引用数，当对象的引用计数为 0 时代表这个对象可被回收。

对象的 refcount 减少的时机：修改变量、函数返回（释放局部变量）、unset 变量

对于数组和对象而言，可能存在变量中的成员引用变量本身的情况，也就是循环引用，这样会造成这个变量永远不会被内存回收，而成为垃圾。

PHP 里对于这种情况给出了垃圾回收机制：如果数组、对象的引用计数减少而且不为零，则认为他们可能是垃圾，把他们放到垃圾收集器里。等垃圾收集器到了一定的数量之后，进行垃圾处理：对所有可能的垃圾 refcount 减 1，如果为 1，说明是垃圾，则进行内存回收；如果不为 1，说明还有其他变量在使用，refcount 重新加 1；这种对象复用以及垃圾回收机制在其他语言中也有体现：redis 中也使用了引用计数表示每个对象的引用数量。

\7. PHP7 与 PHP5 的区别

改进的性能 - 将 PHPNG 代码合并到 PHP7 中，速度是 PHP 5 的两倍。

降低内存消耗 - 优化的 PHP 7 使用较少的资源。

标量类型声明 - 现在可以强制执行参数和返回类型。

一致的 64 位支持 - 对 64 位体系结构机器的一致支持。

改进了异常层次 - 异常层次得到了改进

许多致命的错误转换为例外 - 例外范围增加，涵盖许多致命的错误转换为例外。

安全随机数发生器 - 增加新的安全随机数发生器 API。

已弃用的 SAPI 和扩展已删除 - 各种旧的和不受支持的 SAPI 和扩展从最新版本中删除。

空合并运算符（？） - 添加了新的空合并运算符。

返回和标量类型声明 - 支持所添加的返回类型和参数类型。

匿名类 - 支持匿名添加。

零成本断言 - 支持零成本断言增加。

\8. MongoDB 应用场景

mongodb 支持副本集、索引、自动分片，可以保证较高的性能和可用性。

更高的写入负载

默认情况下，MongoDB 更侧重高数据写入性能，而非事务安全，MongoDB 很适合业务系统中有大量 “低价值” 数据的场景。但是应当避免在高事务安全性的系统中使用 MongoDB，除非能从架构设计上保证事务安全。

高可用性

MongoDB 的复副集 (Master-Slave) 配置非常简洁方便，此外，MongoDB 可以快速响应的处理单节点故障，自动、安全的完成故障转移。这些特性使得 MongoDB 能在一个相对不稳定（如云主机）的环境中，保持高可用性。

数据量很大或者未来会变得很大

依赖数据库 (MySQL) 自身的特性，完成数据的扩展是较困难的事，在 MySQL 中，当一个单达表到 5-10GB 时会出现明显的性能降级，此时需要通过数据的水平和垂直拆分、库的拆分完成扩展，使用 MySQL 通常需要借助驱动层或代理层完成这类需求。而 MongoDB 内建了多种数据分片的特性，可以很好的适应大数据量的需求。

基于位置的数据查询

MongoDB 支持二维空间索引，因此可以快速及精确的从指定位置获取数据。

表结构不明确

在一些传统 RDBMS 中，增加一个字段会锁住整个数据库 / 表，或者在执行一个重负载的请求时会明显造成其它请求的性能降级。通常发生在数据表大于 1G 的时候（当大于 1TB 时更甚）。 因 MongoDB 是文档型数据库，为非结构货的文档增加一个新字段是很快速的操作，并且不会影响到已有数据。另外一个好处当业务数据发生变化时，是将不在需要由 DBA 修改表结构。

\9. PHP 短信验证码防刷机制

1、时间限制：60 秒后才能再次发送

从发送验证码开始，前端（客户端）会进行一个 60 秒的倒数，在这一分钟之内，用户是无法提交多次发送信息的请求的。这种方法虽然使用得比较普遍，但是却不是非常有用，技术稍微好点的人完全可以绕过这个限制，直接发送短信验证码。

2、手机号限制：同一个手机号，24 小时之内不能够超过 5 条

对使用同一个手机号码进行注册或者其他发送短信验证码的操作的时候，系统可以对这个手机号码进行限制，例如，24 小时只能发送 5 条短信验证码，超出限制则进行报错（如：系统繁忙，请稍后再试）。然而，这也只能够避免人工手动刷短信而已，对于批量使用不同手机号码来刷短信的机器，这种方法也是无可奈何的。

3、短信验证码限制：30 分钟之内发送同一个验证码

网上还有一种方法说：30 分钟之内，所有的请求，所发送的短信验证码都是同一个验证码。第一次请求短信接口，然后缓存短信验证码结果，30 分钟之内再次请求，则直接返回缓存的内容。对于这种方式，不是很清楚短信接口商会不会对发送缓存信息收取费用，如果有兴趣可以了解了解。

4、前后端校验：提交 Token 参数校验

这种方式比较少人说到，个人觉得可以这种方法值得一试。前端（客户端）在请求发送短信的时候，同时向服务端提交一个 Token 参数，服务端对这个 Token 参数进行校验，校验通过之后，再向请求发送短信的接口向用户手机发送短信。

5、唯一性限制：微信产品，限制同一个微信 ID 用户的请求数量

如果是微信的产品的话，可以通过微信 ID 来进行识别，然后对同一个微信 ID 的用户限制，24 小时之内最多只能够发送一定量的短信。

6、产品流程限制：分步骤进行

例如注册的短信验证码使用场景，我们将注册的步骤分成 2 步，用户在输入手机号码并设置了密码之后，下一步才进入验证码的验证步骤。

7、图形验证码限制：图形验证通过后再请求接口

用户输入图形验证码并通过之后，再请求短信接口获取验证码。为了有更好的用户体验，也可以设计成：一开始不需要输入图形验证码，在操作达到一定量之后，才需要输入图形验证码。具体情况请根据具体场景来进行设计。

8、IP 及 Cookie 限制：限制相同的 IP/Cookie 信息最大数量

使用 Cookie 或者 IP，能够简单识别同一个用户，然后对相同的用户进行限制（如：24 小时内最多只能够发送 20 条短信）。然而，Cookie 能够清理、IP 能够模拟，而且 IP 还会出现局域网相同 IP 的情况，因此，在使用此方法的时候，应该根据具体情况来思考。

9、短信预警机制，做好出问题之后的防护

以上的方法并不一定能够完全杜绝短信被刷，因此，我们也应该做好短信的预警机制，即当短信的使用量达到一定量之后，向管理员发送预警信息，管理员可以立刻对短信的接口情况进行监控和防护。

\10. 如何设计一个高并发的系统

① 数据库的优化，包括合理的事务隔离级别、SQL 语句优化、索引的优化

② 使用缓存，尽量减少数据库 IO

③ 分布式数据库、分布式缓存

④ 服务器的负载均衡

\11. PHP 的控制反转 (IOC) 和依赖注入 (DI) 概念

IOC（inversion of control）控制反转模式；控制反转是将组件间的依赖关系从程序内部提到外部来管理；

DI（dependency injection）依赖注入模式；依赖注入是指将组件的依赖通过外部以参数或其他形式注入；

\12. mySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据

相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6 种数据淘汰策略：

volatile-lru：从已设置过期时间的数据集（server.db [i].expires）中挑选最近最少使用的数据淘汰

volatile-ttl：从已设置过期时间的数据集（server.db [i].expires）中挑选将要过期的数据淘汰

volatile-random：从已设置过期时间的数据集（server.db [i].expires）中任意选择数据淘汰

allkeys-lru：从数据集（server.db [i].dict）中挑选最近最少使用的数据淘汰

allkeys-random：从数据集（server.db [i].dict）中任意选择数据淘汰

no-enviction（驱逐）：禁止驱逐数据

 

 

1.写出一个能创建多级目录的PHP函数（新浪网技术部）

```
<?php

    /**

     * 创建多级目录

     * @param $path string 要创建的目录

     * @param $mode int 创建目录的模式，在windows下可忽略

     */

    function create_dir($path,$mode = 0777)

    {

        if (is_dir($path)) {

            # 如果目录已经存在，则不创建

            echo "该目录已经存在";

        } else {

            # 不存在，创建

            if (mkdir($path,$mode,true)) {

                echo "创建目录成功";

            } else {

                echo "创建目录失败";

            }

        }

    }

?>
```

2.写出smarty模板的特点（新浪网技术部）

速度快，编译型，缓存技术，插件机制，强大的表现逻辑

3.打开php.ini中的safe_mode，会影响哪些函数？至少说出6个。（新浪）

safe_mode，PHP安全模式，它提供一个基本安全的共享环境，在一个有多个用户账户存在的php开发的web服务器上。当安全模式打开的时候，一些函数将被完全的禁止，而另一些函数的功能将会受到限制，如：chdir,move_uploaded_file,chgrp,parse_ini_file,chown,rmdir,copy,rename,fopen,require,mkdir,unlink等。
注意，在php5.3以上版本，safe_mode被弃用，在php5.4以上版本，则将此特性完全去除了。

4.抓取远程图片到本地,你会用什么函数?([51.com](https://link.zhihu.com/?target=http%3A//51.com)笔试题)

file_get_contents或者curl

5.PHP的垃圾收集机制是怎样的（腾讯）

PHP可以自动进行内存管理，清除不再需要的对象。
PHP使用了引用计数(reference counting)这种单纯的垃圾回收(garbage collection)机制。每个对象都内含一个引用计数器，每个reference连接到对象，计数器加1。当reference离开生存空间或被设为NULL，计数器减1。当某个对象的引用计数器为零时，PHP知道你将不再需要使用这个对象，释放其所占的内存空间。

6.请写一段PHP代码，确保多个进程同时写入同一个文件成功（腾讯）

核心思路：加锁

```
<?php

    $fp = fopen("lock.txt","w+");

    if (flock($fp,LOCK_EX)) {

        //获得写锁，写数据

        fwrite($fp, "write something");

  

        // 解除锁定

        flock($fp, LOCK_UN);

    } else {

        echo "file is locking...";

    }

    fclose($fp);

?>
```

7.写一个函数，尽可能高效的，从一个标准url里取出文件的扩展名，例如:

[http://www.sina.com.cn/abc/de/fg.php?id=1需要取出php或.php（新浪）](https://link.zhihu.com/?target=http%3A//www.sina.com.cn/abc/de/fg.php%3Fid%3D1%E9%9C%80%E8%A6%81%E5%8F%96%E5%87%BAphp%E6%88%96.php%EF%BC%88%E6%96%B0%E6%B5%AA%EF%BC%89)

```
<?php

    // 方案一

    function getExt1($url){

        $arr = parse_url($url);

        //Array ( [scheme] => http [host] => www.sina.com.cn [path] => /abc/de/fg.php [query] => id=1 )

  

        $file = basename($arr['path']);

        $ext = explode('.', $file);

        return $ext[count($ext)-1];

    }

  

    // 方案二

    function getExt2($url){

        $url = basename($url);

        $pos1 = strpos($url,'.');

        $pos2 = strpos($url,'?');

  

        if (strstr($url,'?')) {

            return substr($url,$pos1+1,$pos2-$pos1-1);

        } else {

            return substr($url,$pos1);

        }

  

    }

  

    $path = "http://www.sina.com.cn/abc/de/fg.php?id=1";

    echo getExt1($path);

    echo "<br />";

    echo getExt2($path);

?>
```

相关题目：使用五种以上方式获取一个文件的扩展名，要求：dir/upload.image.jpg，找出.jpg或者jpg，必须使用PHP自带的处理函数进行处理，方法不能明显重复，可以封装成函数，比如get_ext1(file_name)

8.写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。（新浪）

```
<?php

    function my_scandir($dir){

        $files = array();

        if(is_dir($dir)){

            if ($handle = opendir($dir)) {

                while (($flie = readdir($handle))!== false) {

                    if ($flie!="." && $file!="..") {

                        if (is_dir($dir."/".$file)) {

                            $files[$file] = my_scandir($dir."/".$file);

                        } else {

                            $files[] = $dir."/".$file;

                        }

                    }

                }

                closedir($handle);

                return $files;

            }

        }

    }

?>
```

9.简述论坛中无限分类的实现原理。（新浪）

创建类别表如下：

CREATE TABLE category(

cat_id smallint unsigned not null auto_increment primary key comment'类别ID',

cat_name VARCHAR(30)NOT NULL DEFAULT''COMMENT'类别名称',

parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0 COMMENT'类别父ID'

)engine=MyISAM charset=utf8;

编写一个函数，递归遍历，实现无限分类

<?php

    function tree($arr,$pid=0,$level=0){
    
        static $list = array();
    
        foreach ($arr as $v) {
    
            //如果是顶级分类，则将其存到$list中，并以此节点为根节点，遍历其子节点
    
            if ($v['parent_id'] == $pid) {
    
                $v['level'] = $level;
    
                $list[] = $v;
    
                tree($arr,$v['cat_id'],$level+1);
    
            }
    
        }
    
        return $list;
    
    }

?>

0.写一个函数，算出两个文件的相对路径，如b='/a/b/12/34/c.php';计算出a的相对路径应该是../../c/d（新浪）

```
<?php

    function releative_path($path1,$path2){

        $arr1 = explode("/",dirname($path1));

        $arr2 = explode("/",dirname($path2));

  

        for ($i=0,$len = count($arr2); $i < $len; $i++) {

            if ($arr1[$i]!=$arr2[$i]) {

                break;

            }

        }

  

        // 不在同一个根目录下

        if ($i==1) {

            $return_path = array();

        }

  

        // 在同一个根目录下

        if ($i != 1 && $i < $len) {

            $return_path = array_fill(0, $len - $i,"..");

        }

  

        // 在同一个目录下

        if ($i == $len) {

            $return_path = array('./');

        }

  

        $return_path = array_merge($return_path,array_slice($arr1,$i));

        return implode('/',$return_path);

    }

  

    $a = '/a/b/c/d/e.php';

    $b = '/a/b/12/34/c.php';

    $c = '/e/b/c/d/f.php';

    $d = '/a/b/c/d/g.php';

  

    echo releative_path($a,$b);//结果是../../c/d

    echo "<br />";

    echo releative_path($a,$c);//结果是a/b/c/d

    echo "<br />";

    echo releative_path($a,$d);//结果是./

    echo "<br />";

?>
```

11.mysql_fetch_row()和mysql_fetch_array()有什么分别？

mysql_fetch_row()把数据库的一列储存在一个以零为基数的数组中，第一栏在数组的索引0，第二栏在索引1，依此类推。
mysql_fetch_assoc()把数据库的一列储存在一个关联数组中，数组的索引就是字段名称，例如我的数据库查询送回“first_name”、“last_name”、“email”三个字段，数组的索引便是“first_name”、“last_name”和“email”。
mysql_fetch_array()可以同时送回mysql_fetch_row()和mysql_fetch_assoc()的值。

12.有一个网页地址,比如PHP开发资源网主页:[phpres.com/index.html](https://link.zhihu.com/?target=http%3A//www.phpres.com/index.html),如何得到它的内容?

方法1(对于PHP5及更高版本):

$readcontents=fopen("http://www.phpres.com/index.html","rb");

$contents=stream_get_contents($readcontents);

fclose($readcontents);

echo $contents;

echo file_get_contents("http://www.phpres.com/index.html");

3.谈谈对mvc的认识

由模型(model)，视图(view)，控制器(controller)完成的应用程序。
model层负责提供数据，和数据库有关的操作都交给模型层来处理，view层则提供交互的界面，并输出数据，而controller层则负责接收请求，并分发给相应的model来处理，然后调用view层来显示。

14.What does the GD library do?（Yahoo）

GD库提供了一系列用来处理图片的API，使用GD库可以处理图片，或者生成图片。在网站上GD库通常用来生成缩略图或者用来对图片加水印或者对网站数据生成报表。自从PHP 4.3.0版本后GD便内建在PHP系统中。

15.What function can you use to open a file for reading and writing?（Yahoo）

A.fget();
B.file_open();
C.fopen();
D.open_file();
答案：C
fget()这不是一个PHP函数，会引致执行错误。
file_open()这不是一个PHP函数，会引致执行错误。
fopen()这是正确答案，fopen()可以用来开启档案以便读写。
open_file()这不是一个PHP函数，会引致执行错误。

16.Smarty的原理

smarty是一个模板引擎，使用smarty主要是为了实现逻辑和外在内容的分离，如果不使用模板的话，通常的做法就是php代码和html代码混编。使用了模板之后，则可以将业务逻辑都放到php文件中，而负责显示内容的模板则放到html文件中。
Smarty在执行display方法的时候，读取模板文件，并进行数据替换，生成编译文件，之后每次访问都会直接访问编译文件，读取编译文件省去了读取模板文件，和字符串替换的时间，所以可以更快，编译文件里时间戳记录模板文件修改时间，如果模板被修改过就可以检测到，然后重新编译（编译是把静态内容保存起来，动态内容根据传入的参数不同而不同）。
如果启用了缓存，则会根据编译文件生成缓存文件，在访问的时候如果有缓存文件并且缓存文件没有过期，则直接访问缓存文件。

相关题目1：能够使HTML和PHP分离开使用的模板

smarty，phplib等

相关题目2：您是否用过模板引擎?如果有您用的模板引擎的名字是?

Smarty

17.PHP如何实现页面跳转

方法一：php函数跳转，缺点，header头之前不能有输出，跳转后的程序继续执行，可用exit中断执行后面的程序。
header("Location:网址");//直接跳转
header("refresh:3;url=[axgle.za.NET](https://link.zhihu.com/?target=http%3A//axgle.za.NET)");//三秒后跳转

方法二：利用meta
echo"<meta http-equiv=refresh content='0;url=网址'>";

18.PHP可以和sql server/oracle等数据库连接吗?

可以

19.使用哪些工具进行版本控制？

SVN或者CVS

相关题目：您是否用过版本控制软件?如果有您用的版本控制软件的名字是?

TortoiseSVN-1.2.6

20.写出一个正则表达式，过虑网页上的所有JS/VBS脚本（即把script标记及其内容都去掉）：

过滤JavaScript脚本参考：

<?php

    header("content-type:text/html;charset=utf-8");

  


    $script = "以下内容不显示：<script type='text/javascript'>alert('cc');</script>";
    
    $pattern = '/<script[^>]*?>.*?</script>/si';

  


    echo preg_replace($pattern, "脚本内容", $script);//以下内容不显示：脚本内容

?>

21.给定一行文本$string，如何编写一个正则表达式来去掉所有的HTML标记？

方案一，使用PHP内建函数strip_tags()除去HTML标签

方案二，自定义函数，如下：

```
<?php

    header("content-type:text/html;charset=utf-8");

  

    function strip_html_tags($str){

        $pattern = '/<("[^"]*"|\'[^\']\*\'|[^>"\'])*>/';

        return preg_replace($pattern,'',$str);

    }

  

    // 实例

    $html = '<p id="">ddddd<br /></p>';

    echo strip_html_tags($html);

    echo "<br />";

  

    $html = '<p id=">">bb<br />aaa<br /></p>';

    echo strip_html_tags($html);

?>
```

22.请写一个函数验证电子邮件的格式是否正确（要求使用正则）（新浪）

preg_match('/^[\w\-\.]+@[\w\-]+(\.\w+)+$/',$email);

相关题目：请用正则表达式写一个函数，验证电子邮件的格式是否正确。（鑫众人云）

23.请对POSIX风格和兼容Perl风格两种正则表达式的主要函数进行类比说明（腾讯）

主要区别有以下三种：

preg_replace()里面的正则可以写成型如："/.xxx/"而ereg_replace()里面的正则需写成型如 "xxx"

preg_replace()能操作数组，而ereg_replace()不可以

在逆向引用用preg_replace()可使用0-99个，而ereg_replace()最多为9个

使用Perl兼容正则表达式语法的preg_match()函数通常是比ereg()更快的替代方案。

24.请写出并说明如何在命令行下运行PHP脚本（写出两种方式）同时向PHP脚本传递参数？（腾讯）

首先进入php安装目录
php -f d:/wamp/www/1.php 其中-f参数指定要执行的php文件
php -r phpinfo(); 其中-r表示直接执行php代码，无需写开始结束标记

25.使用正则表达式提取一段标识语言（html或xml）代码段中指定标签的指定属性值（需考虑属性值对不规则的情况，如大小写不敏感，属性名值与等号间有空格等）。此处假设需提取test标签的attr属性值，请自行构建包含该标签的串（腾讯）

编写如下函数：

```
<?php

    header("content-type:text/html;charset=utf-8");

  

    function getAttrValue($str,$tagName,$attrName){

        $pattern1="/<".$tagName."(\\s+\\w+\s*=\\s*([\\'\\\"]?)([^\\'\\\"]*)(\\2))*\\s+".$attrName."\\s*=\\s*([\\'\\\"]?)([^\\'\\\"]*)(\\5)(\\s+\\w+\\s*=\\s*([\\'\\\"]?)([^\\'\\\"]*)(\\9))*\\s*>/i";

  

        $arr=array();

        $re=preg_match($pattern1,$str,$arr);

  

        if($re){

            echo"<br/>\$arr[6]={$arr[6]}";

        }else{

            echo"<br/>没找到。";

        }

    }

  

    // 示例

    $str1="<test attr='ddd'>";

    getAttrValue($str1,"test","attr");//找test标签中attr属性的值,结果为ddd

    $str2="<test2 attr='ddd'attr2='ddd2't1=\"t1 value\"t2='t2 value'>";

    getAttrValue($str2,"test2","t1");//找test2标签中t1属性的值，结果为t1 value

?>
```









### 1，Http 和Https的区别

第一：http是超文本传输协议，信息是明文传输，https是具有安全性的ssl加密传输协议

第二：http和https使用的是完全不同的连接方式，端口也不一样，前者80 或者443

第三：http连接很简单，是无状态的。https协议是由ssl+http协议构建的可进行加密传输，身份认证的网络协议。

2.什么方法来加快页面的加载速度

1，用到服务器资源时在打开，不用时，立即关闭服务器资源。

2，数据库添加索引

3，页面可生成静态

4，图片等大文件单独放在一个服务器

5，能不查询数据库的尽量不去数据取数据，可以放在缓存中。

3.表单中 get与post提交方法的区别?

答:get是发送请求HTTP协议通过url参数传递进行接收,而post是实体数据,可以通过表单提交大量信息.

### 4.echo ,print,print_r 的区别：

echo 是php语句，无返回值。

print,print_r是函数,有返回值。
print（）  只能打印出简单类型变量的值(如int,string)

print_r（） 可以打印出复杂类型变量的值(如数组,对象)
echo   输出一个或者多个字符串

5.session与cookie区别

session与cookie相同：跨页面、不跨用户

session与cookie不相同：

1、session可以存储任意类型的数据，但cookie只能存储字符串

2、cookie产生在服务器端、存储在客户端

session产生在服务器端、存储在服务器端

6.魔术常量

答案：

__LINE__文件中的当前行号。

__FILE__文件的完整路径和文件名。

__FUNCTION__函数名称

__CLASS__类的名称

__METHOD__类的方法名

 

7.数据库中的事务是什么?
答:事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。

8.1优化MYSQL数据库的方法。
1、选择合适的字段的数据类型

1)能用数字不用字符串

2)char、varchar、text 能用varchar不用char

3）给字段加not null 避免在表中出现NULL关键字(default 值)

2、选择合适的字段充当主键

1)建议每张表必须有主键

2)用数字类型的字段充当主键

- 拆分表
- 拆分字段，将文章的标题与内容分开

2）拆分记录，将今年的记录与往年的记录分开

- 给字段合理添加索引

a.格式:

(普通索引)->

创建:CREATE INDEX <索引名> ON tablename (索引字段)

修改:ALTER TABLE tablename ADD INDEX [索引名] (索引字段)

创表指定索引:CREATE TABLE tablename([...],INDEX[索引名](索引字段))

(唯一索引)->

创建:CREATE UNIQUE <索引名> ON tablename (索引字段)

修改:ALTER TABLE tablename ADD UNIQUE [索引名] (索引字段)

创表指定索引:CREATE TABLE tablename([...],UNIQUE[索引名](索引字段))

(主键)->

它是唯一索引,一般在创建表是建立,格式为:

CREATA TABLE tablename ([...],PRIMARY KEY[索引字段])

5、事务处理:

a.保证数据完整性,例如添加和修改同时,两者成立则都执行,一者失败都失败

mysql_query("BEGIN");

mysql_query("INSERT INTO customerinfo (name) VALUES ('$name1')";

mysql_query("SELECT * FROM `orderinfo` where customerid=".$id");

mysql_query("COMMIT");

6、锁定表,优化事务处理:

a.我们用一个 SELECT 语句取出初始数据，通过一些计算，用 UPDATE 语句将新值更新到表中。

包含有 WRITE 关键字的 LOCK TABLE 语句可以保证在 UNLOCK TABLES 命令被执行之前，

不会有其它的访问来对 inventory 进行插入、更新或者删除的操作

mysql_query("LOCK TABLE customerinfo READ, orderinfo WRITE");

mysql_query("SELECT customerid FROM `customerinfo` where id=".$id);

mysql_query("UPDATE `orderinfo` SET ordertitle='$title' where

customerid=".$id);

mysql_query("UNLOCK TABLES");

7、使用外键,优化锁定表

a.把customerinfo里的customerid映射到orderinfo里的customerid,

任何一条没有合法的customerid的记录不会写到orderinfo里

CREATE TABLE customerinfo(

customerid INT NOT NULL,

PRIMARY KEY(customerid)

)TYPE = INNODB;

CREATE TABLE orderinfo(

orderid INT NOT NULL,

customerid INT NOT NULL,

PRIMARY KEY(customerid,orderid),

FOREIGN KEY (customerid) REFERENCES customerinfo

(customerid) ON DELETE CASCADE

)TYPE = INNODB;

注意:'ON DELETE CASCADE',该参数保证当customerinfo表中的一条记录删除的话同时也会删除order

表中的该用户的所有记录,注意使用外键要定义事务安全类型为INNODB;

8、优化查询语句

a用内连接代替子查询代替子查询，用sphinx代替like模糊查询

 

b最好在相同字段进行比较操作,在建立好的索引字段上尽量减少函数操作

例子1:

SELECT * FROM order WHERE YEAR(orderDate)<2008;(慢)

SELECT * FROM order WHERE orderDate<"2008-01-01";(快)

例子2:

SELECT * FROM order WHERE addtime/7<24;(慢)

SELECT * FROM order WHERE addtime<24*7;(快)

例子3:

SELECT * FROM order WHERE title like "%good%";

SELECT * FROM order WHERE title>="good" and name<"good";

- 缓存，静态化
- 选择合适存储引擎用Innodb增删改，用myisam查询
- 主从数据库
- 负载均衡
- 最好拿数字类型的字段充当where条件
- 最好拿相同类型的字段进行比对(避免发生数据类型的转换)
- 不要在具有索引的字段上添加数据库函数(索引失效)

8.2请简述项目中优化sql语句执行效率的方法,从哪些方面,sql语句性能如何分析?

答：（1）选择最有效率的表名顺序

（2）WHERE子句中的连接顺序

（3）SELECT子句中避免使用‘*’

（4）用Where子句替换HAVING子句

（5）通过内部函数提高SQL效率

（6）避免在索引列上使用计算。

（7）提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉。

### 9.对于大流量网站，采用什么方法解决访问量问题？

1，确认服务器的硬件是否足够支持当前的流量

2，优化数据库的访问

3，禁止外部的盗链

4，控制大文件的下载

5，使用不同主机分流主要流量

6，使用流量分析统计软件

10.一个函数，能够遍历一个文件夹下的所有文件和子文件夹（20分）

function dir_recurse($dir) {

$i = 1;

if($handle = opendir($dir)) {

while(false !== ($file = readdir($handle))) {

if($file != "."&& $file != ".." ) {

if(is_dir($dir."/".$file) == true) {

$fullpath = $dir."/".$file;

dir_recurse($fullpath);

echo "$fullpath\n";

$i++;

}else {

$fullpath = $dir."/".$file;

echo "$fullpath\n";

 

$i++;

}

}

}

closedir($handle);

}

}

10.2写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。

function my_scandir($dir){

$files = array();

if ( $handle = opendir($dir) ) {

while ( ($file = readdir($handle)) !== false ) {

if ( $file != ".."&& $file != "." ) {

if ( is_dir($dir . "/" . $file) ) {

$files[$file] = scandir($dir . "/" . $file);

}else {

$files[] = $file;

}

}

}

closedir($handle);

return $files;

}

}

 

### 11、能够使HTML和PHP分离开使用的模板(1分)

### 答:Smarty,Dwoo,TinyButStrong,Template Lite,Savant,phemplate,XTemplate

### 12、使用哪些工具进行版本控制?(1分)

### 答:cvs,svn,vss;

13、如何实现字符串翻转?(3分)

英文:

strrev($a)

中文或其他文字：

中文：GB2312， 代码是使用GB2312编码

<?php

function reverse($str)

{

$ret = "";

len=mb s trwidth( len=mbstrwidth(len = mb_strwidth(str,"GB2312");

for(i=0; i=0;i=0; i< len; len;len; i++)

{

arr[]=mb s ubstr( arr[]=mbsubstr(arr[] = mb_substr(str, $i, 1, "GB2312");

}

return implode("", array_reverse($arr));

}

print_r(reverse("你好"));

 

14.PHP的意思(送1分)

PHP是一个基于服务端来创建动态网站的脚本语言，您可以用PHP和HTML生成网站主页

15.MYSQL取得当前时间的函数是?，格式化日期的函数是(2分)

答:now(),date()

16.用PHP写出显示客户端IP与服务器IP的代码1分)

答:打印客户端IP:echo $_SERVER[‘REMOTE_ADDR’]; 或者: getenv('REMOTE_ADDR');

打印服务器IP:echo gethostbyname("www.bolaiwu.com")

17、语句include和require的区别是什么?为避免多次包含同一文件，可用(?)语句代替它们?

答:require->require是无条件包含也就是如果一个流程里加入require,无论条件成立与否     都会先执行require

include->include有返回值，而require没有(可能因为如此require的速度比include快)

注意:包含文件不存在或者语法错误的时候require是致命的,include不是

### 18.http请求返回状态码

400 请求无效

401 未授权

403 请求被禁止

404 请求资源不存在

405 请求资源被禁止

406 无法接受

407 要求代理身份验证

500 Internal Server Error 服务端源代码错误

600 源站没有返回响应头部，只返回实现内容

19，linux授权码：

600 属主有读写权限

644 属主有读写权限，属性组有读权限

700 属主有读写执行权限

755 属主有读写执行权限，属性组有读，执行权限

711 属主有读写执行权限，属性组有执行权限

666 所有用户都有文件的读写权限

777 所有用户都有文件的读写执行权限

20.有一个网页地址, 比如PHP开发资源网主页: http://www.phpres.com/index.html,如何得到它的内容?($1分)

答:方法1(对于PHP5及更高版本):

$readcontents = fopen("http://www.phpres.com/index.html", "rb");

$contents = stream_get_contents($readcontents);

fclose($readcontents);

echo $contents;

方法2:

echo file_get_contents("http://www.phpres.com/index.html");

21.在PHP中error_reporting这个函数有什么作用? (1分)

答:设置错误级别与错误信息回报

22.JS表单弹出对话框函数是?获得输入焦点函数是? (2分)

答:弹出对话框: alert(),prompt(),confirm()

获得输入焦点 focus()

23.foo()和@foo()之间有什么区别?(1分)

答:@foo()控制错误输出

24、mysql_fetch_row() 和mysql_fetch_array之间有什么区别? (1分)

答:mysql_fetch_row是从结果集取出1行数组,作为枚举

mysql_fetch_array是从结果集取出一行数组作为关联数组,或数字数组,两者兼得

25、GD库是做什么用的? (1分)

答:gd库提供了一系列用来处理图片的API，使用GD库可以处理图片，或者生成图片。

在网站上GD库通常用来生成缩略图或者用来对图片加水印或者对网站数据生成报表。

### 26.面向对象编程

有两个重要的概念：类和对象

类是具备某项功能的抽象模型，实际应用中，还需要对类进行实例化后使用。这样就引入了对象的概念。

对象是类进行实例化后的一个产物，是一个实体。

封装 ：把客观的事物封装成一个抽象的类。

继承：子类继承父类，可以使用父类的属性和方法。可以实现接口，同时实现接口中的所有方法

多态：覆盖和重载 子类可以覆盖父类中的方法；一个类中可以同时拥有同一个函数名的方法，但是方法的参数不同，实现的结果也不同。

### 27.php框架

熟悉YII ，Thinkphp还有laravel ,symfony2,cakephp

### 28.mysql存储引擎

ISAM： 查询速度快、增删改慢，支持全文索引、不支持外键、不支持事务

MyISAM：  ISAM升级版

Memory：  数据驻留在内存、速度快、数据管理不稳定、断电后数据全部丢失

InnoDB：  速度较慢、支持外键、支持事务、不支持全文索引

使用的存储引擎

MyISAM：内容管理系统(新闻、官网、电商、软件下载、房屋、招聘...) 可读不可改 大部分是浏览信息

InnoDB：技术型网站(bbs、blog、webo、oa...)

 

### 29.数据库操作流程

$link = mysql_connect("localhost","root","root");

mysql_select_db("test",$link);

$sql ="select * from table";

$result = mysql_query($sql);

while($row =mysql_fetch_****($result) ){

$arr[]=$row;

}

$row = mysql_fetch_array($result) 意思：$row['name'] 和$row[1] 都可以取到值

$row = mysql_fetch_row($result)) 意思：$row[1] 只有用索引取值，偏移量从0开始。

$row = mysql_fetch_assoc($result)) 意思： $row['name'] 字段名作为索引取值 抽取一条记录转为 关联数组，失败返回false

### 30.php 加密函数

crypt($str[,$slat]) 可以完成单向加密功能

md5()

sha1() 返回一个40位的十六进制数，

加密扩展库

Mcrypt() 和Mash

31、字符串“to upper case” 分别用php，shell ，js实现将字符串中的字符全部转换成大写并输出。（5分）

Php实现： echo strtoupper(‘to upper case’)

Shell实现：echo "to upper case" | tr 'a-z' 'A-Z'

Js实现：

<script language="javascript">var stmp1 = " to upper case ";alert(stmp1.toLocaleUpperCase());//转换成大写alert(stmp1.toUpperCase())//转换成大写</script>

32.防止SQL注入

1）一般使用 addslashes 函数

addslashes 函数在制定的预定义字符前添加反斜杠

- 对字段和密码MD5加密处理
- 预处理过滤处理

33、用PHP打印出前一天的时间,格式是2006-5-10 22:21:21

<?php

//echo date('Y-m-d H:i:s',time()-60*60*24

echo date("Y:m:d H:i:s",strtotime("-1 day"));

?>

34.如何实现字符串翻转？

其实PHP本身就有字符串翻转的函数:strrev(),不妨试试echo strrev($str);不过

所有的这三种方法都不能解决中文字符串翻转的问题，会出错的。

代码

<?php

function reverse($var)

{

$res="";

for($i=0,$j=strlen($var);$i<$j;$i++)

{

$res=$var[$i].$res;

}

return $res;

}

$tmpvar="wofang";

$res=reverse($tmpvar);

echo $res;

?>

35.实现中文字串截取无乱码的方法。

mb_substr()

36.以下哪一句不会把 John 新增到 users 阵列？

$users[] = 'john';

成功把 John 新增到阵列 users。

array_add($users,’john’);

函式 array_add() 无定义。

array_push($users,‘john’);

成功把 John 新增到阵列 users。

$users ||= 'john';

语法错误。

37.sort()、assort()、和 ksort() 有什么分别？它们分别在什么情况下使用？

sort()

根据阵列中元素的值，以英文字母顺序排序，索引键会由 0 到 n-1 重新编号。主

要是当阵列索引键的值无关疼痒时用来把 阵列排序。

assort()

PHP 没有 assort() 函式，所以可能是 asort() 的笔误。

asort()

与 sort() 一样把阵列的元素按英文字母顺序来排列，不同的是所有索引键都获得保留，特别适合替联想阵列排序。

ksort()

根据阵列中索引键的值，以英文字母顺序排序，特别适合用于希望把索引键排序的联想阵列。

38.以下的代码会产生什么？为什么？

$num =10;

function multiply(){

$num =$num *10;

}

multiply();

echo $num;

由于函式 multiply() 没有指定 $num 为全域变量（例如 global $num 或者

$_GLOBALS['num']），所以 $num 的值是 10。

39.些函式可以用来在现正执行的脚本中插入函式库？

对这道题目不同的理解会有不同的答案，我的第一个想法是插入 PHP 函式库不外乎

include()、include_once()、require ()、require_once()，但细心再想，“函式库”也应该包括 com 物件和 .net 函式库，所以我们的答案也要分别包括

com_load 和 dotnet_load，下次有人提起“函式库”的时候，别忘记这两个函式。

40.foo() 与 @foo() 有什么分别？

foo() 会执行这个函式，任何解译错误、语法错误、执行错误都会在页面上显示出来。

@foo() 在执行这个函式时，会隐藏所有上述的错误讯息。

很多应用程式都使用 @mysql_connect() 和 @mysql_query 来隐藏 mysql 的错误讯息，我认为这是很严重的失误，因为错误 不该被隐藏，你必须妥善处理它们，可能的话解决它们。

- “===”是什么？试举一个“==”是真但“===”是假的例子。

“===”是给既可以送回布尔值“假”，也可以送回一个不是布尔值但却可以赋与“假”值的函式，strpos() 和 strrpos()  便是其中两个例子。

问题的第二部份有点困难，想一个“==”是假，但是“===”是真的例子却很容易，

 

相反的例子却很少。但我终于找到以下的 例子：

if (strpos("abc", "a") == true){  // 这部分永不会被执行，因为 "a" 的位

置是 0，换算成布尔值“假”}if  (strpos("abc", "a") === true){  // 这部份

会被执行，因为“===”保证函式 strpos() 的送回值不会换算成布尔值.}

42、如何修改SESSION的生存时间(1分).

答:方法1:将php.ini中的session.gc_maxlifetime设置为9999重启apache

方法2:$savePath = "./session_save_dir/";

$lifeTime = 小时 * 秒;

session_save_path($savePath);

session_set_cookie_params($lifeTime);

session_start();

方法3:setcookie() and session_set_cookie_params($lifeTime);

43、在PHP中，heredoc是一种特殊的字符串，它的结束标志必须?(1分)

答:heredoc的语法是用"<<<"加上自己定义成对的标签，在标签范围內的文字视为一

个字符串

例子:

$str = <<<SHOW

my name is Jiang Qihui!

SHOW;

1. 在PHP中error_reporting这个函数有什么作用? (1分)

答:设置错误级别与错误信息回报

1. 请写一个函数验证电子邮件的格式是否正确 (2分)

答:function checkEmail($email)

{

$pregEmail = "/([a-z0-9]*[-_\.]?[a-z0-9]+)*@([a-z0-9]*[-_]?[a-z0-

 

9]+)+[\.][a-z]{2,3}([\.][a-z]{2})?/i";

return preg_match($pregEmail,$email);

}

46、请写出数据类型(int char varchar datetime text)的意思; 请问varchar和char

有什么区别(2分)

答:int是数字类型,char固定长度字符串,varchar实际长度字符串,datetime日期时

间型,text文本字符串

char的场地固定为创建表设置的长度,varchar为可变长度的字符

47、检测一个变量是否有设置的函数是否?是否为空的函数是?(2分)

答:isset($str),empty($str);

48、取得查询结果集总数的函数是?(1分)

答:mysql_num_rows($result);

49 简述如何得到当前执行脚本路径，包括所得到参数。

<?php

echo "http://".$_SERVER['SERVER_NAME'].$_SERVER['PHP_SELF']."?".$_SERVER

['QUERY_STRING'];

//echo "http://".$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI'];

?>

50 请举例说明在你的开发过程中用什么方法来加快页面的加载速度

- 要用到服务器资源时才打开
- 及时关闭服务器资源，
- 数据库添加索引，
- 页面可生成静态，图片等大文件单独服务器。
- 使用代码优化工具啦

51． 给定一个用逗号分隔一组值的字符串，以下哪个函数能在仅调用一次的情况下就

把每个独立的值放入一个新创建的数组？

A．strstr()

B．不可能只调用一次就完成

C．extract()

D．explode()√

E．strtok()

 

52．如果用+操作符把一个字符串和一个整型数字相加，结果将怎样？

A．解释器输出一个类型错误

B．字符串将被转换成数字，再与整型数字相加

C．字符串将被丢弃，只保留整型数字√

D．字符串和整型数字将连接成一个新字符串

E．整形数字将被丢弃，而保留字符串

53．以下脚本输出什么？

$s = '12345';

$s[$s[1]] = '2';

echo $s;

?>

A．12345

B．12245√

C．22345

D．11345

54．以下脚本输出什么？

$x = 'apple';

echo substr_replace ($x, 'x', 1, 2);

?>

A．x

B．axle√

C．axxle

D．applex

E．xapple

55． 函数______能读取文本文件中的一行。读取二进制文件或者其他文件时，应当

用______函数。

A．fgets(), fseek()

B．fread(), fgets()

C．fputs(), fgets()

D．fgets(), fread()√

E．fread(), fseek()

 

56．哪个函数能够往文本文件中写入一个字符串？

答案：fwrite()和fputs()两个函数在这里都可以，而后者其实是前者的别名。在

PHP中，写入二进制数据和写入字符串没有区别。

57．函数______能判断一个文件是否可写。

答案：is_writeable

58．以下哪个选项能将文件指针移到开头？

A．reset()

B．fseek(-1)

C．fseek(0, SEEK_END)

 D．fseek(0, SEEK_SET)√

E．fseek(0, SEEK_CUR)

59、include的功能和require一样，不同的是，require不能用在[  ]

A、判断语句或循环里，

B、连接语句里

C、声明语句里

D、文件的开头

E、文件的中间√

50、下面建立与MySQL Server的连接语法正确的是：[ ]

A、$link=connect("host_name","user_name","password");

B、$link=mysql_connect("host_name","user_name","password");√

C、$link=mysqlconnect("host_name","user_name","password");

D、$link=mysql_pconnect("host_name","user_name","password");√

E、$link=pconnect("host_name","user_name","password");

51.将字符串转换成小写

strtolower(): 该函数将传入的字符串参数所有的字符都转换成小写,并以小定形式

放回这个字符串

52.将字符转成大写

strtoupper(): 该函数的作用同strtolower函数相反,是将传入的字符参数的字符全

部转换成大写,并以大写的形式返回这个字符串.用法同strtolowe()一 样.

53.将字符串首字符转换成大写

ucfirst(): 该函数的作用是将字符串的第一个字符改成大写,该函数返回首字符大

写的字符串.用法同strtolowe()一样.

54.将字符串每个单词的首字符转换成大写

ucwords(): 该函数将传入的字符串的每个单词的首字符变成大写.如"hello

world",经过该函数处理后,将返回"Hello Word".用法同strtolowe()一样.

55、NoSQL：Not Only SQL

思想：网站产生的数据，一部分存储数据库、一部分存到NoSQL相关产品

NoSQL产品

1、Memcache：内存(速度快、数据量小)、数据的过期时间

2、MongoDB：文档数据库

3、Redis：内存(速度快、数据量小)、库、没有过期时间

1. 什么样的数据，存储在什么位置？

MySQL：稳定的数据

NoSQL：活跃的数据

57缓存分类

1、缓存数据存储位置不同

1)文件缓存

2)内存缓存

2、缓存的数据量的不同

1)页面缓存

2)局部缓存

3)局部不缓存

4)数据缓存(变量缓存、动态缓存)

Memcache：内存缓存、变量缓存

58 .LINUX命令

查看当前目录下所有内容    ls

在当前目录下，新建一个文件夹 mkdir 文件夹名

删除指定的文件夹       rmdir 文件夹名  只能删除空目录

在当前目录下新建一个空白文件 touch 文件名

删除当前目录下的一个文件   unlink文件名

删除文件或文件夹       rm

复制文件           cp

移动文件或文件夹       mv

文件或文件夹重命名      mv

查看完整的工作目录      pwd

切换目录：          cd   cd/ 返回根目录

文件传输           ftp

查看文件内容         cat 文件名

查看文件编码         file 文件名

查找文件           find 路径 -name 文件名

修改文件或文件夹权限

权限种类：r 4(读)、w 2(写)、x 1(执行)

权限操作符：+(赋予权限)、-(收回权限)

用户种类：a(所有人)、u(文件拥有者)、g(组用户)、o(其他用户)

查看权限：ls -l

-rw-r--r-- a.txt

drwxr-xr-x hello

第1位：是文件还是文件夹(-文件、d文件夹)

第234位：u用户的权限

第567位：g用户的权限

最后三位：o用户的权限

1)将最大权限赋予a.txt

chmod a+r+w+x a.txt

chmod 777 a.txt

2)设置a.txt权限，收回o用户的wx权限

chmod o-w-x a.txt

4)设置a.txt权限：u:rw g:r o:r

chmod 644 a.txt

5)设置hello文件夹权，给予最大权限(不影响子文件)

chmod 777 hello

6)设置hello文件夹权，给予最大权限(影响子文件)

chmod -R 777 hello

59、创建文件exer1，设置访问权限为rw-r--r--，现要增加所有用户的执行权限和同组用户的写权限,写出操作过程的命令（10分）

touch exer1

chmod 644 exer1

增加权限

chmod a+x exer1

chmod g+w exer1

或者

chmod 775 exer1

60易出现编码的地方

- 文件保存格式的编码
- <meta http-equiv=”content-type” content=”text/html;charset=utf-8”>
- Header();
- Msq本身的编码（修改ini）
- Set names gbk;
- Mysql_query(“set names utf8”);
- Iconv()PHP的系统函数进行转码

 61.PHP工作原理

- 一个网站运行时客户端有无数个，服务器通常只有一个（负载均衡）
- 开发环境的安装2，PHP5.4，MYSQL5.3-------开源，可以跨平台
- 配置文件：conf(Apache), php.ini my.ini
- PHP文档组成：HTML，css，js，jquery，PHP
- PHP语法风格：xml风格，短风格，ASP风格（已过时），脚本风格
- <?php ?>注意：位置任意，同一页面可以出现多次，不能嵌套，里面只能出现php代码，需要转字符串输出
- 运行在服务器端
- 注释：单行注释，多行注释

62数据类型：

- 标量类型：integer，Float，String，boolean
- 复合类型：Array，Object
- 特殊类型：Resource，Null
- 伪类型：mixed，number，callback（回调函数）

63.PHP中被认为是false的值：

0,   0.0，    null，    空数组，    空字符串，  false

64.求两个日期的差数，例如2012-2-27 ~ 2013-05-6 的日期差数

<?php

function get_days($date1, $date2){

$time1 = strtotime($date1);

$time2 = strtotime($date2);

return ($time2-$time1)/86400;

}

echo get_days("2013-05-6", "2012-2-27");

?>

65什么是MVC？

回答：MVC由Model（模型）, View（视图）和Controller（控制器）组成，PHP MVC可以更高效地管理好3个不同层的PHP代码。

Model：数据信息存取层。

View：view层负责将应用的数据以特定的方式展现在界面上。

Controller：通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

66.PHP中获取图像尺寸大小的方法是什么？

回答：getimagesize () 获取图片的尺寸

Imagesx () 获取图片的宽度

Imagesy () 获取图片的高度

67.如何在PHP中定义常量？

回答：PHP中使用Define () 来定义常量。

define (“Newconstant”, 30);

### 68.如何不使用submit按钮来提交表单？

如果我们不想用submit按钮来提交表单，我们也可以用超链接来提交，我们可以这样写代码：

<a href=”javascript: document.myform.submit();”>Submit Me</a>

### 69.简述论坛中无限分类的实现原理。

答：无限极分类，那么应该是考察递归函数吧！

第一步：建立测试数据库：

CREATE TABLE `category` ( `id` smallint(5) unsigned NOT NULL auto_increment, `fid` smallint(5) unsigned NOT NULL default '0', `value` varchar(50) NOT NULL default '', PRIMARY KEY (`id`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8;

 

第二步：插入测试数据：

INSERT INTO `category` ( `fid`, `value`) VALUES (0, 'PHP点点通博客PHPDDT.COM'), (1,'a'), (1,'b'), (2,'c'), (2,'d'), (4,'e')

第三步：递归输出分类：

70.试述isset()和empty()的区别

isset() 测试变量是否存在 empty() 测试变量是否为空

71.请用尽可能少的语句实现对输入Email地址进行验证的功能

[eregi('^[_a-z0-9\]+(/.[_a-z0-9-]+)*@[a-z0-9]+(/.[a-z0-9-]+)*$',$emailaddress)](mailto:eregi(' rel=)

### 72.使用PHP描述冒泡排序和快速排序算法，对象可以是一个数组

/冒泡排序（数组排序）

function bubble_sort($array)

{

$count = count($array);

if ($count <= 0) return false;

for($i=0; $i<$count; $i++){

for($j=$count-1; $j>$i; $j–){

if ($array[$j] < $array[$j-1]){

$tmp = $array[$j];

$array[$j] = $array[$j-1];

$array[$j-1] = $tmp;

}

}

}

return $array;

}

//快速排序（数组排序）

function quick_sort($array) {

if (count($array) <= 1) return $array;

$key = $array[0];

$left_arr = array();

$right_arr = array();

for ($i=1; $i<count($array); $i++){

if ($array[$i] <= $key)

$left_arr[] = $array[$i];

else

$right_arr[] = $array[$i];

}

$left_arr = quick_sort($left_arr);

$right_arr = quick_sort($right_arr);

return array_merge($left_arr, array($key), $right_arr);

}

73、使用PHP描述顺序查找和二分查找（也叫做折半查找）算法，顺序查找必须考虑效率，对象可以是一个有序数组

//二分查找（数组里查找某个元素）

function bin_sch($array, $low, $high, $k){

if ($low <= $high){

$mid = intval(($low+$high)/2);

if ($array[$mid] == $k){

return $mid;

}elseif ($k < $array[$mid]){

return bin_sch($array, $low, $mid-1, $k);

}else{

return bin_sch($array, $mid+1, $high, $k);

}

}

return -1;

}

//顺序查找（数组里查找某个元素）

function seq_sch($array, $n, $k){

$array[$n] = $k;

for($i=0; $i<$n; $i++){

if($array[$i]==$k){

break;

}

}

if ($i<$n){

return $i;

}else{

return -1;

}

}

74.写一个二维数组排序算法函数，能够具有通用性，可以调用php内置函数

function array_sort($arr, $keys, $order=0) {

if (!is_array($arr)) {

return false;

}

$keysvalue = array();

foreach($arr as $key => $val) {

$keysvalue[$key] = $val[$keys];

}

if($order == 0){

asort($keysvalue);

}else {

arsort($keysvalue);

}

reset($keysvalue);

foreach($keysvalue as $key => $vals) {

$keysort[$key] = $key;

}

$new_array = array();

foreach($keysort as $key => $val) {

$new_array[$key] = $arr[$val];

}

return $new_array;

}

75.utf-8转换成gbk的函数是？

iconv("gbk",""UTF-8,"我们"); mb_convert_encoding($str, "GBK", "UTF-8")

76.Php中分割字符串成数组的函数和连接数组成字符串的函分别有哪些？

explode() split() ;implode() join()

### 77.说几个你知道的设计模式？

单例模式： 保证一个类仅有一个实例，并提供一个访问他的全局访问点例如框架中的数据库连接

简单工厂模式： 它具有创建对象的某些方法，可以使用工厂类创建对象，而不直接使用 new。例如初始化数据库的时候会用到，比如MySQL，MSSQL

策略模式： 针对一组算法，将每一个算法封装到具有共同接口的独立的类中，例如进入个人主页时，根据浏览者的不同，给予不同的显示与操作

注册模式： 提供了在程序中有条理的存放并管理一组全局对象 (object)，例如ZF框架中的Zend_Registry::set

适配器模式： 将不同接口适配成统一的API接口，例如数据操作有mysql、mysqli、pdo等，可利用适配器模式统一接口

观察者模式： 一个对象通过添加一个方法使本身变得可观察。当可观察的对象更改时，它会将消息发送到已注册的观察者。例如实现实现消息推送

装饰器模式： 不修改原类代码和继承的情况下动态扩展类的功能，例如框架的每个Controller文件会提供before和after方法

迭代器模式： 提供一个方法顺序访问一个聚合对象中各个元素，在PHP中将继承 Iterator 类

原型模式： 实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。

78.echo，print()，print_r()，printf()，sprintf()，var_dump()有什么区别?

echo ：是语句不是函数，没有返回值，可输出多个变量值，不需要圆括号。不能输出数组和对象，只能打印简单类型(如int,string)

print ：是语句不是函数，有返回值 1 ，只能输出一个变量，不需要圆括号。不能输出数组和对象，只能打印简单类型(如int,string)。

print_r

：是函数，可以打印复合类型，例如：stirng、int、float、array、object等，输出array时会用结构表示，而且可以通过print_r($str,true)来使print_r不输出而返回print_r处理后的值

printf ：是函数，把文字格式化以后输出（参看C语言）

sprintf ：是函数，跟printf相似，但不打印，而是返回格式化后的文字，其他的与printf一样。

var_dump ：函数，输出变量的内容、类型或字符串的内容、类型、长度。常用来调试。

79.echo count(“abc”); 输出什么?

答案:1

1. 写个函数用来对二维数组排序。

答案：array_multisort() 。

81.对于大流量的网站,您采用什么样的方法来解决访问量问题?

首先，确认服务器硬件是否足够支持当前的流量。

其次，优化数据库访问。

第三，禁止外部的盗链。

第四，控制大文件的下载。

第五，使用不同主机分流主要流量

第六，使用流量分析统计软件。

82.error_reporting(2047)什么作用？

答案：相当于 error_reporting(‘E_ALL’); 输出所有的错误。

83、 简述如何得到当前执行脚本路径，包括所得到参数。

访问http://temp.com/phpinfo.php?id=1

echo $_SERVER['SCRIPT_URL']; //得到/phpinfo.php

echo $_SERVER["SCRIPT_URI"]; //得到http://temp.com/phpinfo.php

echo $_SERVER["SCRIPT_FILENAME"]; //得到F:/www/Temp/phpinfo.php

echo $_SERVER["REQUEST_URI"]; //得到/phpinfo.php?id=1

echo $_SERVER["SCRIPT_NAME"]; //得到/phpinfo.php

参考server.php http://lesson.com/test/server.php?id=1

1. 写出session的运行机制。

session创建时，是否会在服务端记录一个cookie?cookie里面的内容是什么？

session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。

当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识-称为sessionid，如果已包含一个sessionid则说明以前已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，sessionid的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个sessionid将被在本次响应中返回给客户端保存。_

保存这个sessionid的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发给服务器。一般这个cookie的名字都是类似于SEEESIONID。r

由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把sessionid传递回服务器。经常被使用的一种技术叫做URL重写，就是把sessionid直接附加在URL路径的后面，附加方式也有两种，一种是作为URL路径的附加信息，表现形式为http://…../xxx;SEEESIONID=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764比

另一种是作为查询字符串附加在URL后面，表现形式为http://…../xxx?SEEESIONID=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764参

为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个SEEESIONID。

85.Cookie的原理及使用？

Cookie是网站保存在浏览器客户端的信息，也就是说保存在访客的机器里的变量，一般随着HTTP头发送到服务器端。在Cookie生效之后及失效之前，客户每次发出页面请求的时候（包括PHP页面和静态html页面），都会把Cookie一块发送到服务器，只要我们针对它进行相应的处理，就可以实现变量”追随”。到

86.Form中的get和post方法，在数据传输过程中分别对应了HTTP协议中的GET和POST方法。二者主要区别如下：

a、Get是用来从服务器上获得数据，而Post是用来向服务器上传递数据。

b、Get将表单中数据的按照variable=value的形式，添加到action所指向的URL后面，并且两者使用”?”连接，而各个变量之间使用”&”连接；Post是将表单中的数据放在form的数据体中，按照变量和值相对应的方式，传递到action所指向URL。u

c、Get是不安全的，因为在传输过程，数据被放在请求的URL中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。Post的所有操作对用户来说都是不可见的。而

d、Get传输的数据量小，这主要是因为受URL长度限制；而Post可以传输大量的数据，所以在上传文件只能使用Post（当然还有一个原因，将在后面的提到）。

e、Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。

f、Get是Form的默认方法。

*.Post传输数据时，不需要在URL中显示出来，而Get方法要在URL中显示。

*.Post传输的数据量大，可以达到2M，而Get方法由于受到URL长度的限制,只能传递大约1024字节.

.Post顾名思义,就是为了将数据传送到服务器段,Get就是为了从服务器段取得数据.而Get之所以也能传送数据,只是用来设计告诉服务器,你到底需要什么样的数据.Post的信息作为http请求的内容，而Get是在Http头部传输的。提

87.PHP5中魔术方法函数有哪几个，请举例说明各自的用法

__sleep

__wakeup

__toString

__set_state

__construct,

__destruct

__call,

__get,

__set,

__isset,

__unset

__clone

__autoload

1. isset()和empty()的区别

两者都是测试变量用的。但是isset()是 测试变量是否被赋值 ，而empty()是测试 一个已经被赋值的变量是否为空

。如果一个变量没被赋值就引用在php里是被允许的,但会有notice提示。如果一个变量被赋空值，$foo=””或者$foo=0或者$foo=false,那么empty($foo)返回真，isset($foo)也返回真，就是说赋空值不会注销一个变量。要注销一个变量，可以用d

unset($foo)或者$foo=NULL。

89.以下哪一句不会把 John 新增到 users 阵列？

$users[] = ‘john’;

成功把 John 新增到阵列 users。

array_add($users,’john’);

函式 array_add() 无定义。

array_push($users,‘john’);

成功把 John 新增到阵列 users。

$users ||= ‘john’;

语法错误。

90.以下哪一个函式可以把浏览器转向到另一个页面？

redir()这不是一个 PHP 函式，会引致执行错误。

header()这个是正确答案，header() 用来插入卷头资料，可以用来使浏览器转向到另一个页面，例如：

header(“Location: http://www.phpmst.com/”);

location()这不是一个 PHP 函式，会引致执行错误。

redirect()这不是一个 PHP 函式，会引致执行错误。

91.PHP中的非静态方法可以通过静态调用吗，反之呢？

其实问题是问没有通过static定义的方法，能否通过”对象名::方法名“这样的形式来调用。答案是会产生一个strict错误，但在会继续执行代码。

反之，能否通过“对象名->方法名“的形式来调用static定义的方法？答案是不能，会出错并中断程序执行。

92.使用utf-8编码，以下代码输出结果是什么？strlen函数是计算字符串的字节数还是字符数？

$str = “您好hello”;

答案：echo strlen($str);

11 strlen() 函数返回字符串的长度。

93..什么是时间戳？时间戳能代表的最小年份和最大年份是多少？

答案：（格林威治时间 1970 年 1 月 1 日 00:00:00）到当前时间的秒数。

有效的时间戳典型范围是格林威治时间 1901 年 12 月 13 日 20:45:54 到 2038 年 1 月 19 日 03:14:07。（此范围符合

32 位有符号整数的最小值和最大值）。

不过在 PHP 5.1 之前此范围在某些系统（如 Windows）中限制为从 1970 年 1 月 1 日到 2038 年 1 月 19 日。

1. MyISAM与innoDB存储引擎有何差别？

答案：A、两者在文件构成上有区别；

B、InnoDB支持事务处理，MyISAM不支持；

C、对无WHERE子句的COUNT(*)操作的不同：MyISAM中保存了该值，直接读取，InnoDB需要作全表扫描；

D、锁的区别：InnoDB支持表级锁和行级锁，MyISAM只支持表级锁；

E、索引会缓存数据，而MYISAM不会；

F、INNODB不区分char和varchar；

G、INNODB支持hash索引，而MYISAM不支持；

H、InnoDB不支持FULLTEXT类型的索引；

I、InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from

table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含

where条件时，两种表的操作是一样的；

J、对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引；

K、DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除；

L、LOAD TABLE FROM

MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。

95..如何记录php程序错误至系统日志？

答案：将PHP的log_errors开启即可，默认是记录到WEB服务器的日志文件里，比如Apache的error.log文件。

当然也可以记录错误日志到指定的文件中。

代码如下:

\# vim /etc/php.inidisplay_errors = Off

log_errors = On

error_log = /var/log/php-error.log

另外也可以设定error_log = syslog，使这些错误信息记录到操作系统的日志里。

display_errors = Off //不显示错误

error_reporting 设定错误讯息回报的等级

96.用最少的代码写一个求3值最大值的函数.

答案： function($a,$b,$c){

return $a>$b? ($a>$c? $a : $c) : ($b>$c? $b : $c );

}

97.在PHP中，heredoc是一种特殊的字符串，它的结束标志必须?(1分)

答:heredoc的语法是用”<<<”加上自己定义成对的标签，在标签范围內的文字视为一个字符串

例子:

$str = <<<SHOW

my name is Jiang Qihui!

SHOW;

 

### 98.字符串函数

chr — 通过ASCII码值返回指定的字符

ord — 通过指定的字符返回ASCII码值

explode — 使用一个字符串分割另一个字符串

implode — 将一个一维数组的值转化为字符串

join — 别名implode

htmlspecialchars — 把预定义的字符转换为HTML实体（比如说大于小于）

nl2br — 在字符串所有新行之前插入HTML换行标记

strip_tags — 从字符串中去除 HTML 和 PHP 标记

lcfirst — 使一个字符串的第一个字符小写

ucfirst — 将字符串的首字母转换为大写

ucwords — 将字符串中每个单词的首字母转换为大写

md5 — 加密，返回32位的字符串

sha1 — 加密，返回40位的字符串

number_format — 以千位分隔符方式格式化一个数字

trim — 去除字符串首尾处的空白字符（或者其他字符）

ltrim — 删除字符串开头的空白字符（或其他字符）

rtrim — 删除字符串末端的空白字符（或者其他字符）

chop — rtrim 的别名

str_replace — 子字符串替换

str_ireplace — str_replace的忽略大小写版本

str_pad — 使用另一个字符串填充字符串为指定长度

str_repeat — 重复一个字符串

str_shuffle — 随机打乱一个字符串

str_split — 将字符串转换为数组

strstr — 查找字符串的首次出现

strchr — 别名 strstr

stristr — strstr 函数的忽略大小写版本

strrchr — 查找指定字符在字符串中的最后一次出现

strpos — 查找字符串首次出现的位置

stripos — 查找字符串首次出现的位置（不区分大小写）

strripos — 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写）

strrpos — 计算指定字符串在目标字符串中最后一次出现的位置

strlen — 获取字符串长度

strrev — 反转字符串

strtolower — 将字符串转化为小写

strtoupper — 将字符串转化为大写

substr — 截取字符串

### 99.数组函数

答案：

array_shift — 将数组开头的单元移出数组

array_pop — 将数组最后一个单元弹出（出栈）

array_unshift — 在数组开头插入一个或多个单元

array_push — 将一个或多个单元压入数组的末尾（入栈）

array_keys — 返回数组中部分的或所有的键名

array_values — 返回数组中所有的值

in_array — 检查数组中是否存在某个值

array_key_exists — 检查给定的键名或索引是否存在于数组中

key_exists — 别名 array_key_exists

array_rand — 从数组中随机取出一个或多个单元

array_reverse — 返回一个单元顺序相反的数组

array_unique — 移除数组中重复的值

array_merge — 合并一个或多个数组

count — 计算数组中的单元数目或对象中的属性个数

sizeof — count 的别名

array_sum — 计算数组中所有值的和

array_flip — 交换数组中的键和值

array_count_values — 统计数组中所有的值出现的次数

shuffle — 将数组打乱

reset — 将数组的内部指针指向第一个单元

prev — 将数组的内部指针倒回一位

current — 返回数组中的当前单元

pos — current 的别名

each — 返回数组中当前的键／值对并将数组指针向前移动一步

next — 将数组中的内部指针向前移动一位

end — 将数组的内部指针指向最后一个单元

 

sort — 对数组排序

rsort — 对数组逆向排序

asort — 对数组进行排序并保持索引关系

arsort — 对数组进行逆向排序并保持索引关系

ksort — 对数组按照键名排序

krsort — 对数组按照键名逆向排序

compact — 建立一个数组，包括变量名和它们的值

range — 快速创建数组

1. 单例模式，创建mysqli数据库链接的单例对象

class Db

{

private static $instance;

public $handle;

private function __construct($host, $username, $password, $dbname)

{

$this->handle = NULL;

$this->getcon($host, $username, $password, $dbname);

}

public static function getBb()

{

self::$instance = new Db();

 

return self::$instance;

}

private function getcon($host, $username, $password, $dbname)

{

if($this->handle!=NULL){

return true;

}

$this->handle = mysqli_connect($host, $username, $password,

$dbname);

}

}